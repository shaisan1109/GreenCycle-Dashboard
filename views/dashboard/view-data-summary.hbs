<!-- Display search parameters if current route has query -->    
<div id="filter-section" class="filter-section" data-section="filters">
    <center>
        <h2 style="margin: 0;">Search Parameters</h2>
    </center>
    <div class="filter-columns">

        <!-- Location Filters -->
        <div class="filter-column">
            <label for="region">Region</label>
            {{regionName}}

            <label for="province">Province</label>
            {{provinceName}}

            <label for="municipality">City/Municipality</label>
            {{municipalityName}}

            <label for="barangay">Barangay</label>
            {{barangayName}}
        </div>

        <!-- Author & Date Filters -->
        <div class="filter-column">
            <label>Title</label>
            {{query.title}} {{#ifEquals query.title undefined}}ALL{{/ifEquals}}

            <label for="filter-author">Author</label>
            {{query.author}} {{#ifEquals query.author undefined}}ALL{{/ifEquals}}

            <label for="filter-org">Organization Name</label>
            {{query.company}} {{#ifEquals query.company undefined}}ALL{{/ifEquals}}

            <label>Collection Date Range</label>
            <div class="date-range">
                {{query.startDate}} {{#ifEquals query.startDate undefined}}--{{/ifEquals}} to
                {{query.endDate}} {{#ifEquals query.endDate undefined}}--{{/ifEquals}}
            </div>
        </div>

        <!-- Additional Metrics Filters -->
        <div class="filter-column">
            <label>Time Aggregation</label>
            {{#if query.aggregation}}
                {{#ifEquals query.aggregation "monthly"}}Monthly{{/ifEquals}}
                {{#ifEquals query.aggregation "yearly"}}Yearly{{/ifEquals}}
            {{else}}
                Not Set
            {{/if}}
        </div>
    </div>
</div>

<!-- Display charts for aggregated data -->
<!-- Title Card -->
<div class="form-section title-card" style="text-align: center;" data-section="data-title">
    <h1 style="margin-bottom: 0.25rem;">
      GreenCycle Dashboard ‚Äì Data Summary
    </h1>
    <p style="font-size: large;">
        {{#if query.aggregation}}
            {{#ifEquals query.aggregation "monthly"}}Monthly{{/ifEquals}}
            {{#ifEquals query.aggregation "yearly"}}Yearly{{/ifEquals}}
            aggregated data for the requested entries.
        {{else}}
            Overall summary data for the requested entries.
        {{/if}}
    </p>
</div>

<!-- Participants Section -->
<div class="form-section closed" 
     style="background-color: #f0fff4; padding: 1.5rem; border-radius: 12px; margin: 0.5rem 0;">
  
  <h2 class="participants-header" onclick="toggleCategory(this)">
    <span>
      <i class="fa-solid fa-users" style="margin-right: 10px; color: #4CAF50;"></i>
      Participants Included

      <br><span class="click-note">(Click to show list of participants)</span>
    </span>
    <i class="fas fa-chevron-down toggle-icon"></i>
  </h2>

  <div class="form-section participants-list">
    <div class="content" data-section="participants">
      <center>
        <h3>LIST OF PARTICIPANTS</h3>
      </center>
      <!-- Orgs and Users List -->
      <div style="margin-bottom: 1rem; width: 50%">
        <strong style="color:#2d613f;">Organizations & Users:</strong>
        {{#if orgGroups.length}}
          <ul style="padding-left: 1.5rem;">
            {{#each orgGroups}}
              <li>
                <strong>{{company_name}}</strong>
                {{!-- <ul style="list-style-type: circle; padding-left: 1.5rem; margin: 0.25rem 0;">
                  {{#each users}}
                    <li>{{this}}</li>
                  {{/each}}
                </ul> --}}
              </li>
            {{/each}}
          </ul>
        {{else}}
          <p style="margin: 0.5rem 0; color: #777;">None</p>
        {{/if}}
      </div>

      <!-- Locations -->
      <div style="width: 50%">
        <strong style="color:#2d613f;">Locations:</strong>
        {{#if uniqueLocations.length}}
          <ul style="list-style-type: disc; padding-left: 1.5rem; margin: 0.5rem 0;">
            {{#each uniqueLocations}}
              <li style="margin-bottom: 0.25rem; color: #333;">{{this}}</li>
            {{/each}}
          </ul>
        {{else}}
          <p style="margin: 0.5rem 0; color: #777;">None</p>
        {{/if}}
      </div>
    </div>
  </div>
</div>


<!-- Initial Summary -->
<div style="display: flex;">
  <div data-section="data-info">
    <!-- Waste Generation Info -->
    <div class="form-section">
        <h3><i class="fas fa-dumpster"></i> Waste Generation</h3>
        <table class="user-profile">
        <tr>
            <td class="label">Average Waste Generation per Capita (Kg/cap-day)</td>
            <td>{{commaNumber avgInfo.avg_per_capita}}</td>
        </tr>
        <tr>
            <td class="label">Average Annual Waste Generation (kg/year)</td>
            <td>{{commaNumber avgInfo.avg_annual}}</td>
        </tr>
        </table>
    </div>

    <!-- Collection Info -->
    <div class="form-section">
        <h3><i class="fas fa-calendar-alt"></i> Overall Collection Period</h3>
        <table class="user-profile">
        <tr>
            <td class="label">Earliest Start Date</td>
            <td>{{textDate avgInfo.earliest_collection_start}}</td>
        </tr>
        <tr>
            <td class="label">Latest End Date</td>
            <td>{{textDate avgInfo.latest_collection_end}}</td>
        </tr>
        </table>
    </div>
  </div>

  <!-- Map view -->
  <div id="map" style="margin-bottom: 10px; flex: 1;" data-section="map"></div>
</div>

<!-- NEW: Trends Over Time Section -->
<div class="form-section" style="background-color: #f8f9ff; padding: 2rem; border-radius: 12px; border-left: 6px solid #2196F3;" data-section="trends">
  <h2 id="trends-main-title" style="color: #1565C0; font-weight: 600; margin-bottom: 1rem; display: flex">
    <!-- Populated by JS -->
  </h2>
  
  <p style="color: #555; margin-bottom: 1.5rem;">
    Visualize waste generation patterns over time using averaging aggregation:<br>
    <h2>
      <math style="background-color:#fff;padding:10px;border-radius:5px;">
        <mrow>
          <mi>y</mi><mi>(</mi><mi>fc</mi><mi>)</mi>
          <mo>=</mo>
          <mfrac>
            <mn>1</mn>
            <mrow>
              <msub><mi>T</mi><mn>2</mn></msub>
              <mo>-</mo>
              <msub><mi>T</mi><mn>1</mn></msub>
            </mrow>
          </mfrac>
          <mo>√ó</mo>
          <mi>Œ£y(i)</mi>
        </mrow>
      </math>
    </h2>
    Use the aggregation selector to switch between monthly or yearly views. You may drag the horizontal scrollbar on each chart to view further time periods.
  </p>

  <p>This data summary uses entries from multiple sources, shown with the <b>company legends</b> placed on each trend chart.</p>

  <!-- Trend Charts Container -->
  <div id="trend-charts-wrapper">
    <!-- Total Waste Trend with Regression -->
    <div class="trend-chart-box" data-section="trends-wastegen">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-trash"></i> Total Waste Generation Trend with 3rd Degree Polynomial Regression
      </h3>

      <p>This chart shows the <b>total waste generated over time</b>, with a brief regression analysis of the potential growth or reduction of said total waste.</p>
      <ul>
        <li><b style="color:#2196F3;">Actual Data</b> - Shows the waste recorded in each period (month or year), as reported by certain companies.</li>
        <li><b style="color:#FF5722;">Trend Lines</b> - Show the overall trend of the waste based on past data. The solid line represents the trend of actual data, and the dashed line shows how the trend is expected to continue in the future.</li>
        <li><b style="color:rgba(255, 160, 0, 1)">Projected Values</b> <i>(shaded area)</i> - Estimates future waste based on trends, giving an idea of what might happen if things continue the same way.</li>
      </ul>

      <p>Hovering over a dot gives the exact waste amount and the companies responsible.</p>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider">
        Zoom Width&emsp;
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendTotalWasteContainer"
          min="40" 
          max="200" 
          value="50" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>
      <small style="color: gray;">Drag this slider to widen/shorten this chart.</small><br>

      <div class="chart-omission-note">
        <i class="fa-solid fa-circle-info"></i> <b>NOTE:</b> To keep the chart readable, some x-axis labels are hidden when space is limited. Increase the zoom to view more labels.
      </div>

      <center><i>Hover over the data points to view the involved companies and locations.</i></center>

      <!-- Actual chart -->
      <div class="chart-viewport">
        <div id="trendTotalWasteContainer" class="chart-content" style="height: 500px">
          <canvas id="trendTotalWaste"></canvas>
        </div>
      </div>

      <!-- Regression text blurb -->
      <div style="margin-top: 1rem; padding: 1rem; background: #e8f5e9; border-radius: 6px; font-size: 0.9rem;">
        <strong style="color: #2d613f;">üìä Trend Analysis:</strong>
        <span id="regressionStats" style="color: #555;"></span>
      </div>
    </div>

    <!-- Waste by Category Trend -->
    <div class="trend-chart-box" data-section="trends-category">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-layer-group"></i> Waste by Category Over Time
      </h3>

      <p>This chart shows the <b>total amount of waste per category</b> over time.</p>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider">
        Zoom Width&emsp;
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendByCategoryContainer"
          min="75" 
          max="300" 
          value="150" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>
      <small style="color: gray;">Drag this slider to widen/shorten this chart.</small><br>

      <div class="chart-omission-note">
        <i class="fa-solid fa-circle-info"></i> <b>NOTE:</b> To keep the chart readable, some x-axis labels are hidden when space is limited. Increase the zoom to view more labels.
      </div>

      <center><i>Hover over the data points to view the involved companies and locations.</i></center>

      <div class="chart-viewport">
        <div id="trendByCategoryContainer" class="chart-content" style="height: 500px">
          <canvas id="trendByCategory"></canvas>
        </div>
      </div>

      <div style="margin-top: 1rem; padding: 1rem; background: #e8f5e9; border-radius: 6px; font-size: 0.9rem;">
        <strong style="color: #2d613f;">üìä Category Breakdown Analysis:</strong><br><br>
        <span id="categoryStats" style="color: #555;"></span>
      </div>

    </div>

    <!-- Per Capita Trend -->
    <div class="trend-chart-box" data-section="trends-percapita">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-user"></i> Per Capita Waste Trend
      </h3>

      <p>This chart shows estimates on <b>how much waste each person is generating</b> over time.</p>
      <ul><li><b style="color:#FF9800">Orange line with dots</b> - Each point represents the average waste per person for a specific period (month or year).</li></ul>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider">
        Zoom Width&emsp;
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendPerCapitaContainer"
          min="40" 
          max="200" 
          value="50" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>
      <small style="color: gray;">Drag this slider to widen/shorten this chart.</small><br>

      <div class="chart-omission-note">
        <i class="fa-solid fa-circle-info"></i> <b>NOTE:</b> To keep the chart readable, some x-axis labels are hidden when space is limited. Increase the zoom to view more labels.
      </div>

      <center><i>Hover over the data points to view the involved companies and locations.</i></center>

      <!-- Actual chart -->
      <div class="chart-viewport">
        <div id="trendPerCapitaContainer" class="chart-content" style="height: 500px">
          <canvas id="trendPerCapita"></canvas>
        </div>
      </div>

      <!-- Per capita blurb -->
      <div style="margin-top: 1rem; padding: 1rem; background: #e8f5e9; border-radius: 6px; font-size: 0.9rem;">
        <strong style="color: #2d613f;">üìä Trend Analysis:</strong>
        <span id="perCapitaStats" style="color: #555;"></span>
      </div>
    </div>

<!-- ==========================================================
     WASTE GENERATION SIMULATION PANEL (FINAL FULL VERSION)
=========================================================== -->
<div class="form-section" style="background:#f4fff6;padding:1.5rem;border-radius:12px;border-left:6px solid #2e7d32;">

  <!-- Title -->
  <h2 style="color:#2e7d32;font-weight:700;margin-bottom:0.5rem;display:flex;align-items:center;">
    <i class="fa-solid fa-flask" style="margin-right:10px;color:#43a047"></i>
    Waste Generation Simulation
  </h2>

  <p style="color:#444;line-height:1.5;margin-top:0.2rem;">
    This module simulates future waste generation based on historical monthly patterns,
    company participation, and growth over time. Adjust the parameters below to explore
    how changes in the environment affect projected waste output.
  </p>

<!-- ===========================
     SIMULATION INPUTS
============================ -->
<div style="background:#e8f5e9;padding:16px;border-radius:10px;margin-top:1rem;display:flex;flex-direction:column;gap:16px;">

  <!-- Simulation Length -->
  <div class="sim-row">
    <label for="forecastMonths" style="font-weight:600;">Simulation Length (months)</label>
    <input id="forecastMonths" type="number" class="form-control" value="12" min="1" max="240">
    <small style="color:#555;">How many months to simulate (12 = one year, 36 = three years).</small>
  </div>

  <!-- Company Weight Mode -->
  <div class="sim-row">
    <label style="font-weight:600;">Company Weight Mode</label>
    <select id="weightMode" class="form-control">
      <option value="auto">Automatic (from historical waste contribution)</option>
      <option value="manual">Manual (custom user-defined weights)</option>
      <option value="default" selected>Default (Small=0.5, Medium=1, Large=2)</option>
    </select>
    <small style="color:#555;">
      Automatic = compute weights using real historical waste.<br>
      Manual = enter your own weights below.<br>
      Default = fixed multipliers 0.5 / 1 / 2.
    </small>
  </div>

  <!-- Manual Weight Controls -->
  <div id="manualWeightInputs" style="display:none;margin-top:10px;">
    <label style="font-weight:600;">Manual Company Weights</label>
    <div style="display:flex; gap:12px;">
      <div style="flex:1;">
        <label style="font-size:0.9rem;">Small</label>
        <input id="manualSmall" type="number" class="form-control" value="0.5" step="0.1">
      </div>
      <div style="flex:1;">
        <label style="font-size:0.9rem;">Medium</label>
        <input id="manualMedium" type="number" class="form-control" value="1" step="0.1">
      </div>
      <div style="flex:1;">
        <label style="font-size:0.9rem;">Large</label>
        <input id="manualLarge" type="number" class="form-control" value="2" step="0.1">
      </div>
    </div>
    <small style="color:#555;">These override automatic and default weights.</small>
  </div>

  <!-- Added Companies -->
  <div class="sim-row">
    <label style="font-weight:600;">Additional Companies (can be negative)</label>
    <div style="display:flex;gap:14px;margin-top:6px;">
      <div style="flex:1;">
        <label style="font-size:0.9rem;">Small</label>
        <input id="addSmall" type="number" class="form-control" value="0">
      </div>
      <div style="flex:1;">
        <label style="font-size:0.9rem;">Medium</label>
        <input id="addMedium" type="number" class="form-control" value="0">
      </div>
      <div style="flex:1;">
        <label style="font-size:0.9rem;">Large</label>
        <input id="addLarge" type="number" class="form-control" value="0">
      </div>
    </div>
  </div>

  <!-- Growth settings -->
  <div class="sim-row">
    <label style="font-weight:600;">Growth Increase (%)</label>
    <input id="growthPercent" type="number" class="form-control" value="0">
    <small style="color:#555;">Example: 5 means waste increases 5% every growth interval.</small>
  </div>

  <div class="sim-row">
    <label style="font-weight:600;">Growth Interval (months)</label>
    <input id="growthInterval" type="number" class="form-control" value="12" min="1">
    <small style="color:#555;">Example: 12 = yearly growth, 2 = every two months.</small>
  </div>

  <!-- Run -->
  <button id="runSimBtn" class="btn btn-success" style="margin-top:8px;">
    <i class="fa-solid fa-play"></i> Run Simulation
  </button>
</div>


<!-- ===========================
     CHART + EXPORT
============================ -->
<div style="margin-top:20px;background:#fff;padding:14px;border-radius:10px;">
  <div id="chartWrapper"
    style="overflow-x:auto; white-space:nowrap; width:100%; border-radius:8px; background:#fff; padding:12px;">
    <div id="chartZoomContainer" style="display:inline-block; min-width:100%;">
      <canvas id="simulationChart" height="380"></canvas>
    </div>
  </div>

  <div style="margin-top:10px;">
    <label style="font-weight:600;">Zoom</label>
    <input type="range" class="zoom-range" data-target="chartZoomContainer" min="25" max="200" value="100" step="5">
  </div>

  <div style="margin-top:15px; display:flex; gap:12px;">
    <button id="exportSimCSV" class="btn btn-outline-success">
      <i class="fa-solid fa-file-csv"></i> Export CSV
    </button>
    <button id="exportSimXLSX" class="btn btn-outline-primary">
      <i class="fa-solid fa-file-excel"></i> Export Excel
    </button>
  </div>
</div>

<!-- ===========================
     DIAGNOSTICS
============================ -->
<div style="margin-top:18px;">
  <h3 style="color:#2e7d32;font-weight:600;">Simulation Diagnostics</h3>
  <table style="width:100%;border:1px solid #e0e0e0;border-radius:6px;background:white;">
    <tbody id="simDiagnostics" style="font-size:0.95rem;"></tbody>
  </table>
</div>




<!-- ==========================================================
     SCRIPT SECTION
=========================================================== -->
<script>

// ------------------------------------------------------
// SHOW / HIDE MANUAL WEIGHT INPUTS
// ------------------------------------------------------
document.getElementById("weightMode").addEventListener("change", () => {
  const mode = document.getElementById("weightMode").value;
  document.getElementById("manualWeightInputs").style.display =
    mode === "manual" ? "block" : "none";
});


// ------------------------------------------------------
// ZOOM FUNCTION
// ------------------------------------------------------
document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".zoom-range").forEach(slider => {
    const target = document.getElementById(slider.dataset.target);

    let baseWidth = target.getBoundingClientRect().width;

    function applyZoom(val) {
      const percent = Number(val);
      const newWidth = Math.max(300, baseWidth * (percent / 100));
      target.style.width = `${newWidth}px`;
    }

    applyZoom(slider.value);
    slider.addEventListener("input", e => applyZoom(e.target.value));

    window.addEventListener("resize", () => {
      baseWidth = target.getBoundingClientRect().width;
      applyZoom(slider.value);
    });
  });
});


// ------------------------------------------------------
// GLOBAL HOLDER FOR EXPORT
// ------------------------------------------------------
window.lastSimulation = null;
function safeGet(id) {
  const el = document.getElementById(id);
  if (!el) {
    console.log(`[FILTER] ${id} = (element NOT FOUND)`);
    return null;
  }
  const val = el.value?.trim() || null;
  console.log(`[FILTER] ${id} =`, val);
  return val;
}

function collectDataSummaryFilters() {
  const url = new URL(window.location.href);
  const filters = {
    title: url.searchParams.get("title"),
    region: url.searchParams.get("region"),
    province: url.searchParams.get("province"),
    municipality: url.searchParams.get("municipality"),
    barangay: url.searchParams.get("barangay"),
    author: url.searchParams.get("author"),
    company: url.searchParams.get("company"),
    startDate: url.searchParams.get("startDate"),
    endDate: url.searchParams.get("endDate")
  };

  console.log("üìå URL FILTERS ‚Üí", filters);
  return filters;
}




// ------------------------------------------------------
// RUN SIMULATION
// ------------------------------------------------------
async function runSimulation() {

  const payload = {
    horizon: Number(document.getElementById("forecastMonths").value),
filters: collectDataSummaryFilters(),
    additions: {
      small: Number(document.getElementById("addSmall").value),
      medium: Number(document.getElementById("addMedium").value),
      large: Number(document.getElementById("addLarge").value)
    },
    growthPercent: Number(document.getElementById("growthPercent").value),
    growthInterval: Number(document.getElementById("growthInterval").value),
    weightMode: document.getElementById("weightMode").value,

    manualWeights: {
      small: Number(document.getElementById("manualSmall").value),
      medium: Number(document.getElementById("manualMedium").value),
      large: Number(document.getElementById("manualLarge").value)
    }
  };

  let res, json;
  try {
    res = await fetch("/api/simulate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    json = await res.json();
  } catch (err) {
    alert("Simulation failed.");
    console.error(err);
    return;
  }

  window.lastSimulation = json;

  if (!json.success || !json.forecast) {
    renderDiagnostics(json.diagnostics || {});
    return alert("Simulation returned no data.");
  }

  renderSimulationChart(json.forecast);
  renderDiagnostics(json.diagnostics);
}

document.getElementById("runSimBtn").addEventListener("click", runSimulation);


// ------------------------------------------------------
// RENDER CHART
// ------------------------------------------------------
function renderSimulationChart(forecast) {
  const ctx = document.getElementById("simulationChart").getContext("2d");

  if (window.simChart) window.simChart.destroy();

  window.simChart = new Chart(ctx, {
    type: "line",
    data: {
      labels: forecast.map(f => f.period),
      datasets: [{
        label: "Simulated Monthly Waste (kg)",
        data: forecast.map(f => f.mean),
        tension: 0.25,
        borderColor: "rgb(75,192,192)",
        borderWidth: 2
      }]
    },
    options: { responsive: true, maintainAspectRatio: false }
  });
}


// ------------------------------------------------------
// RENDER DIAGNOSTICS
// ------------------------------------------------------
function renderDiagnostics(d) {
  const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  const template = d.monthTemplatePerCompany || [];
  const templateStr = template.length === 12
    ? template.map((v,i)=>`${monthNames[i]}: ${Number(v).toLocaleString()}`).join(", ")
    : "-";

  const weights = d.weightsUsed || {};

  const weightModeDisplay =
    d.weightModeUsed ||
    d.modeUsed ||
    d.weightMode ||
    "unknown";

  document.getElementById("simDiagnostics").innerHTML = `
    <tr><th>Simulation Length</th><td>${d.horizon}</td></tr>
    <tr><th>Starting Month</th><td>${d.anchorMonth}</td></tr>

    <tr><th>Weight Mode</th><td>${weightModeDisplay}</td></tr>

    <tr><th>Weights Applied</th>
        <td>Small: ${weights.small}, Medium: ${weights.medium}, Large: ${weights.large}</td>
    </tr>

    <tr><th>Companies Detected</th><td>${d.distinctCompanies}</td></tr>
    <tr><th>Companies Included</th><td>${(d.companiesInvolved||[]).join(", ")}</td></tr>

    <tr><th>Company Base</th><td>${d.companyBase}</td></tr>
    <tr><th>Scaled Base</th><td>${d.scaledCompanyBase}</td></tr>

    <tr><th>Growth %</th><td>${d.growthPercent}%</td></tr>
    <tr><th>Growth Interval</th><td>${d.growthInterval} months</td></tr>

    <tr><th>Monthly Pattern</th><td>${templateStr}</td></tr>

    <tr><th>Note</th><td>${d.note}</td></tr>
  `;
}



// ------------------------------------------------------
// EXPORT CSV
// ------------------------------------------------------
document.getElementById("exportSimCSV").addEventListener("click", () => {

  if (!window.lastSimulation) return alert("Run a simulation first.");

  const { forecast, diagnostics } = window.lastSimulation;

  let csv = [];
  csv.push("Step,Period,Mean,Upper,Lower");

  forecast.forEach(f => {
    csv.push(`${f.step},${f.period},${f.mean},${f.upper},${f.lower}`);
  });

  csv.push("");
  csv.push("Diagnostics");

  for (const [k,v] of Object.entries(diagnostics)) {
    csv.push(`${k},"${JSON.stringify(v)}"`);
  }

  const blob = new Blob([csv.join("\n")], { type: "text/csv" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = "simulation_results.csv";
  link.click();
});


// ------------------------------------------------------
// EXPORT EXCEL
// ------------------------------------------------------
document.getElementById("exportSimXLSX").addEventListener("click", () => {

  if (!window.lastSimulation) return alert("Run a simulation first.");

  const { forecast, diagnostics } = window.lastSimulation;

  const wb = XLSX.utils.book_new();

  // Forecast sheet
  const ws1 = XLSX.utils.json_to_sheet(forecast);
  XLSX.utils.book_append_sheet(wb, ws1, "Forecast");

  // Diagnostics sheet
  const diag = [["Key","Value"]];
  for (const [k,v] of Object.entries(diagnostics)) {
    diag.push([k, JSON.stringify(v)]);
  }
  const ws2 = XLSX.utils.aoa_to_sheet(diag);
  XLSX.utils.book_append_sheet(wb, ws2, "Diagnostics");

  XLSX.writeFile(wb, "simulation_results.xlsx");
});

</script>



<!-- Compliance Overview -->
<div class="form-section" style="background-color: rgb(240, 255, 240); padding: 10px 15px; border-left: 4px solid #4caf50; margin-bottom: 15px;">
  <h2>About Diversion Rates</h2>
  <p>
    <b>Diversion</b> refers to the portion of waste that is prevented from going to landfills or open dumps, whether before or after collection. This includes waste sent to <b>processing or recovery facilities</b> such as Materials Recovery Facilities (MRFs) where it can be reused, recycled, or converted for other uses.
  </p>
  <p>
    Tracking and meeting <b>diversion targets</b> is essential for reducing landfill dependence, minimizing environmental pollution, and supporting sustainable waste management systems. Regular diversion rate tracking helps local governments and sectors assess their performance and optimize recovery operations.
  </p>
</div>

<div style="display: flex; gap: 10px; flex-wrap: wrap;">
    <!-- Compliance -->
    <div class="form-section" style="background-color: rgb(227, 255, 227); flex: 1 1 calc(50% - 5px);" data-section="compliance-category">
      <h2>Waste Category Diversion Rates</h2>

      <!-- Insights -->
      {{{wasteComplianceNarrative}}}

      <table class="compliance-table">
        <tr>
          <th>Waste Category</th>
          <th>Collected</th>
          <th>Total Generated</th>
          <th>Diversion %</th>
          <th>Target %</th>
          {{!-- <th>Status</th> --}}
        </tr>
        {{#each wasteCompliances}}
          <tr>
            <td>{{supertype_name}}</td>
            <td>{{formatNumber total_collected_weight}} kg</td>
            <td>{{formatNumber total_generated}} kg</td>
            <td>{{diversion_percentage}}%</td>
            <td>{{target_percentage}}%</td>
            {{!-- <td class="{{#if (eq compliance_status 'Non-Compliant')}}non-compliant{{/if}}">{{compliance_status}}</td> --}}
          </tr>
        {{/each}}
      </table>
    </div>

    <div class="form-section" style="background-color: rgb(227, 255, 227); flex: 1 1 calc(50% - 5px);" data-section="compliance-sector">
      <h2>Waste Sector Diversion Rates</h2>
      
      <!-- Insights -->
      {{{sectorComplianceNarrative}}}

      <table class="compliance-table">
        <tr>
          <th>Sector Category</th>
          <th>Collected</th>
          <th>Total Generated</th>
          <th>Diversion %</th>
          <th>Target %</th>
          {{!-- <th>Status</th> --}}
        </tr>
        {{#each sectorCompliances}}
          <tr>
            <td>{{sector_name}}</td>
            <td>{{formatNumber total_collected_weight}} kg</td>
            <td>{{formatNumber total_generated}} kg</td>
            <td>{{diversion_percentage}}%</td>
            <td>{{target_percentage}}%</td>
            {{!-- <td class="{{#if (eq compliance_status 'Non-Compliant')}}non-compliant{{/if}}">{{compliance_status}}</td> --}}
          </tr>
        {{/each}}
      </table>
    </div>
  </div>

<!-- Insight -->
<hr>
<div data-section="insights" class="form-section" style="background-color: #eef8f2; padding: 1.5rem; border-radius: 12px; border-left: 6px solid #4CAF50; margin-top: 2rem;">
  <h2 style="color: #2d613f;"><i class="fa-solid fa-lightbulb" style="margin-right: 8px;"></i>General Waste Category Insights & Recommendations</h2>
  <ul style="font-size: 1.1rem; list-style-type: none; padding-left: 0;">
    {{#each recommendations}}
      <li style="margin-bottom: 1rem;">{{{this}}}</li>
    {{/each}}
  </ul>
</div>

<!-- Data Tabs -->
<div class="tab">
  <button class="tablinks" onclick="openTab(event, 'Chart')" id="defaultOpen">CHART</button>
</div>

<!-- Display A: Chart -->
<div id="Chart" class="tabcontent">
    <!-- Supertype summary pie chart -->
    <div data-section="top-categories">
      <div style="text-align: center;">
        <h2>Top Waste Categories in This Area</h2>
        <p style="font-size: large;" id="summary-description">This pie chart shows the distribution of waste by supertype. Each slice represents the total weight (in kilograms) of waste classified as Biodegradable, Recyclable, Residual, or Special/Hazardous. Hover over a slice to view its percentage and absolute weight.</p>
      </div>

      <div style="display: flex;">
        <div class="pie-chart">
            <canvas id="supertypePieChart">
                <!-- Populated by JS -->
            </canvas>
        </div>

        <div id="summary-legend">
          <div id="summary-insight"></div>
            {{#each legendData}}
                {{#if (gt value 0)}}
                <span class="legend-item" style="background-color: {{color}}">
                    <span class="legend-name">
                        {{label}}
                        <span class="legend-perc">{{calcPercent value ../legendData}}%</span>
                    </span>
                    <span class="legend-kg">
                        {{toFixed value 3}} kg
                    </span>
                </span>
                {{/if}}
            {{/each}}

            <!-- Toggle showing summary or detailed pie -->
            <button id="togglePieBtn" class="no-print"><i class="fa-solid fa-circle-info"></i>&nbsp; Show Detailed Pie Chart</button>
        </div>
      </div>
    </div><br>

    <!-- Subtypes bar charts -->
    <hr>
    <br><center data-section="top-cats">
        <h2>Top Waste Types by Category</h2>
        <p style="font-size: large;">Each bar chart below focuses on one waste category. The bars represent different types under that category, showing how much each contributed to the total weight.</p>
    </center>
    <div class="bar-tab">
        <button class="bar-tablinks" onclick="openBarTab(event, 'Biodegradable')" id="firstBar">BIODEGRADABLE</button>
        <button class="bar-tablinks" onclick="openBarTab(event, 'Recyclable')">RECYCLABLE</button>
        <button class="bar-tablinks" onclick="openBarTab(event, 'Residual')">RESIDUAL</button>
        <button class="bar-tablinks" onclick="openBarTab(event, 'Special/Hazardous')">SPECIAL/HAZARDOUS</button>
    </div>

    <div id="bar-charts-container"></div>

    <!-- Top sectors producing waste -->
    <br><hr><br>
    <div data-section="top-sectors">
      <center>
        <h2>Top Sectors by Waste Output</h2>
        <p style="font-size: large;">This chart shows which economic sectors contribute the most to total waste generation. Use this insight to target waste reduction initiatives by sector.</p>
      </center>
      <div id="sector-insight"></div>
      <div id="sector-chart-container"></div>
    </div>

    <!-- Pie chart per sector -->
    <br><hr><br>
    <center data-section="cats-per-sector">
      <h2>Top Waste Categories per Sector</h2>
      <p style="font-size: large;">Each pie chart below shows the waste composition for a specific economic sector.</p>
    </center>

    <div class="sector-tab">
        <button class="sector-tablinks" onclick="openPieTab(event, 'Residential')" id="firstSector">RESIDENTIAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Commercial')">COMMERCIAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Institutional')">INSTITUTIONAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Industrial')">INDUSTRIAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Health')">HEALTH</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'AgricultureandLivestock')">AGRICULTURE AND LIVESTOCK</button>
    </div>

    <div id="sector-pies-container"></div>
</div>

<!-- Access to chart.js - MUST BE LOADED BEFORE CHART SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>

<!-- Leaflet.js (for map view) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- Participants toggle -->
<script>
function toggleCategory(header) {
    const category = header.parentElement;
    category.classList.toggle('open');

    const content = category.querySelector('.participants-list');
    content.style.display = content.style.display === 'block' ? 'none' : 'block';
}
</script>

<!-- FINAL CORRECTED TRENDS CHART SCRIPT - Total Values (No Daily Averaging) -->
<script>

// ============================================================================
// TREND CHARTS - DATA ENTRY BASED PROPORTIONAL DISTRIBUTION
// Shows TOTAL values per period (not daily averages)
// ============================================================================

function parseFlexibleDate(input) {
  if (!input) return null;
  const str = String(input).trim();
  
  if (input instanceof Date) return input;
  
  if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
    return new Date(str);
  }
  
  if (/^\d{8}$/.test(str)) {
    const year = parseInt(str.slice(0, 4), 10);
    const month = parseInt(str.slice(4, 6), 10) - 1;
    const day = parseInt(str.slice(6, 8), 10);
    return new Date(year, month, day);
  }
  
  if (/^\d{6}$/.test(str)) {
    const year = parseInt(str.slice(0, 4), 10);
    const month = parseInt(str.slice(4, 6), 10) - 1;
    return new Date(year, month, 1);
  }
  
  const parsed = new Date(str);
  return isNaN(parsed) ? null : parsed;
}

function getTimeSpanInDays(startDate, endDate) {
  const msPerDay = 24 * 60 * 60 * 1000;
  return Math.round((endDate - startDate) / msPerDay) + 1;
}

const CATEGORY_NAMES = ['Biodegradable', 'Recyclable', 'Residual', 'Special/Hazardous'];

/**
 * Aggregates data entries by distributing ALL values proportionally
 * Returns TOTAL values per period (not daily averages)
 */
function aggregateDataWithAveraging(dataEntries, aggregationType) {
  const aggregated = {};
  
  console.log(`üìä Processing ${dataEntries.length} data entries for ${aggregationType} aggregation`);
  
  dataEntries.forEach((entry, entryIndex) => {
    
    const collectionStart = parseFlexibleDate(
      entry.collection_start || entry.start_date || entry.date
    );
    const collectionEnd = parseFlexibleDate(
      entry.collection_end || entry.end_date || entry.date
    );
    
    if (!collectionStart || isNaN(collectionStart)) {
      console.warn(`‚ö†Ô∏è Data Entry ${entryIndex + 1}: Invalid collection start date`, entry);
      return;
    }
    
    const actualEndDate = collectionEnd && !isNaN(collectionEnd) ? collectionEnd : collectionStart;
    const entryTotalDays = getTimeSpanInDays(collectionStart, actualEndDate);
    
    const wasteGenerated = parseFloat(entry.annual || entry.total_weight || entry.total_generated || 0);
    const wastePerCapita = parseFloat(entry.avg_per_capita || entry.per_capita || 0);
    
    const wasteByCategory = {};
    
    CATEGORY_NAMES.forEach(categoryName => {
      const categoryKey = categoryName.replace(/[\/\s]/g, '_').toLowerCase();
      const categoryWeight = parseFloat(
        entry[`${categoryKey}_weight`] ||
        entry[`${categoryKey}_generated`] ||
        0
      );
      
      if (categoryWeight > 0) {
        wasteByCategory[categoryName] = categoryWeight;
      }
    });
    
    if (Object.keys(wasteByCategory).length === 0 && wasteGenerated > 0) {
      const defaultCategory = entry.waste_type || 'Unknown';
      wasteByCategory[defaultCategory] = wasteGenerated;
    }
    
    if (entryIndex === 0) {
      console.log('üîç First Data Entry:', {
        id: entry.data_entry_id || entryIndex + 1,
        collectionPeriod: `${collectionStart.toISOString().split('T')[0]} to ${actualEndDate.toISOString().split('T')[0]}`,
        days: entryTotalDays,
        wasteGenerated: wasteGenerated,
        wastePerCapita: wastePerCapita,
        categories: Object.keys(wasteByCategory)
      });
    }
    
    const periodsSpanned = [];
    let currentDate = new Date(collectionStart);
    
    while (currentDate <= actualEndDate) {
      let periodKey, periodStart, periodEnd;
      
      if (aggregationType === 'monthly') {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        periodKey = `${year}-${String(month + 1).padStart(2, '0')}`;
        periodStart = new Date(year, month, 1);
        periodEnd = new Date(year, month + 1, 0);
      } else if (aggregationType === 'yearly') {
        const year = currentDate.getFullYear();
        periodKey = `${year}`;
        periodStart = new Date(year, 0, 1);
        periodEnd = new Date(year, 11, 31);
      }
      
      const overlapStart = collectionStart > periodStart ? collectionStart : periodStart;
      const overlapEnd = actualEndDate < periodEnd ? actualEndDate : periodEnd;
      const daysInThisPeriod = getTimeSpanInDays(overlapStart, overlapEnd);
      
      periodsSpanned.push({
        periodKey,
        periodStart,
        periodEnd,
        daysInThisPeriod,
        overlapStart,
        overlapEnd
      });
      
      if (aggregationType === 'monthly') {
        currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
      } else if (aggregationType === 'yearly') {
        currentDate = new Date(currentDate.getFullYear() + 1, 0, 1);
      }
    }
    
    periodsSpanned.forEach(period => {
      const { periodKey, periodStart, periodEnd, daysInThisPeriod } = period;
      
      if (!aggregated[periodKey]) {
        aggregated[periodKey] = {
          totalWasteGenerated: 0,
          totalPerCapita: 0,
          periodStart: periodStart,
          periodEnd: periodEnd,
          categoryTotals: {},
          entryCount: 0
        };
      }

      // Add company names
      if (!aggregated[periodKey].companyNames) {
        aggregated[periodKey].companyNames = new Set();
      }
      aggregated[periodKey].companyNames.add(entry.company_name);

      // Add location names
      if (!aggregated[periodKey].locationNames) {
        aggregated[periodKey].locationNames = new Set();
      }
      aggregated[periodKey].locationNames.add(entry.location_name);
      
      const proportion = daysInThisPeriod / entryTotalDays;
      
      // Distribute ALL values proportionally
      aggregated[periodKey].totalWasteGenerated += wasteGenerated * proportion;
      aggregated[periodKey].totalPerCapita += wastePerCapita * proportion;
      aggregated[periodKey].entryCount += proportion;
      
      Object.entries(wasteByCategory).forEach(([category, categoryWeight]) => {
        if (!aggregated[periodKey].categoryTotals[category]) {
          aggregated[periodKey].categoryTotals[category] = 0;
        }
        aggregated[periodKey].categoryTotals[category] += categoryWeight * proportion;
      });
      
      if (entryIndex < 3) {
        console.log(`üìÖ Entry ${entryIndex + 1} ‚Üí ${periodKey}: ${(proportion * 100).toFixed(1)}% (${daysInThisPeriod}/${entryTotalDays} days) = ${(wasteGenerated * proportion).toFixed(2)} kg waste, ${(wastePerCapita * proportion).toFixed(4)} per capita`);
      }
    });
  });
  
  // Just store totals - NO division by period days
  Object.keys(aggregated).forEach(periodKey => {
    const period = aggregated[periodKey];
    const periodDays = getTimeSpanInDays(period.periodStart, period.periodEnd);
    period.periodDays = periodDays;
    
    console.log(`üìä ${periodKey}: Total Waste=${period.totalWasteGenerated.toFixed(2)} kg | Total Per Capita=${period.totalPerCapita.toFixed(4)} | Entries=${period.entryCount.toFixed(2)}`);
  });
  
  return aggregated;
}

function generateFutureLabels(lastPeriod, aggregationType, numPeriods = 3) {
  const labels = [];
  
  if (aggregationType === 'monthly') {
    const [year, month] = lastPeriod.split('-').map(Number);
    let currentYear = year;
    let currentMonth = month;
    
    for (let i = 1; i <= numPeriods; i++) {
      currentMonth += 1;
      if (currentMonth > 12) {
        currentMonth = 1;
        currentYear += 1;
      }
      labels.push(`${currentYear}-${String(currentMonth).padStart(2, '0')}`);
    }
  } else if (aggregationType === 'yearly') {
    const year = parseInt(lastPeriod);
    for (let i = 1; i <= numPeriods; i++) {
      labels.push(`${year + i}`);
    }
  }
  
  return labels;
}

function formatPeriodLabel(period, aggregationType) {
  if (aggregationType === 'monthly') {
    const [year, month] = period.split('-');
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return `${monthNames[parseInt(month) - 1]} ${year}`;
  } else if (aggregationType === 'yearly') {
    return period;
  }
  return period;
}

function calculatePolynomialRegression(xValues, yValues, degree = 3) {
  const n = xValues.length;
  const actualDegree = Math.min(degree, n - 1);
  
  const matrix = [];
  const vector = [];
  
  for (let i = 0; i <= actualDegree; i++) {
    const row = [];
    for (let j = 0; j <= actualDegree; j++) {
      let sum = 0;
      for (let k = 0; k < n; k++) {
        sum += Math.pow(xValues[k], i + j);
      }
      row.push(sum);
    }
    matrix.push(row);
    
    let sum = 0;
    for (let k = 0; k < n; k++) {
      sum += yValues[k] * Math.pow(xValues[k], i);
    }
    vector.push(sum);
  }
  
  const coefficients = gaussianElimination(matrix, vector);
  
  const yMean = yValues.reduce((a, b) => a + b, 0) / n;
  const ssTotal = yValues.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
  const ssResidual = yValues.reduce((sum, y, i) => {
    const predicted = evaluatePolynomial(coefficients, xValues[i]);
    return sum + Math.pow(y - predicted, 2);
  }, 0);
  const rSquared = 1 - (ssResidual / ssTotal);
  
  return { coefficients, rSquared, degree: actualDegree };
}

function gaussianElimination(matrix, vector) {
  const n = matrix.length;
  const augmented = matrix.map((row, i) => [...row, vector[i]]);
  
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    for (let k = i + 1; k < n; k++) {
      if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
        maxRow = k;
      }
    }
    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
    
    for (let k = i + 1; k < n; k++) {
      const factor = augmented[k][i] / augmented[i][i];
      for (let j = i; j <= n; j++) {
        augmented[k][j] -= factor * augmented[i][j];
      }
    }
  }
  
  const solution = new Array(n);
  for (let i = n - 1; i >= 0; i--) {
    solution[i] = augmented[i][n];
    for (let j = i + 1; j < n; j++) {
      solution[i] -= augmented[i][j] * solution[j];
    }
    solution[i] /= augmented[i][i];
  }
  
  return solution;
}

function evaluatePolynomial(coefficients, x) {
  let result = 0;
  for (let i = 0; i < coefficients.length; i++) {
    result += coefficients[i] * Math.pow(x, i);
  }
  return result;
}

function generateCompletePeriods(sortedPeriods, aggregation) {
  if (sortedPeriods.length === 0) return [];

  const start = sortedPeriods[0];
  const end = sortedPeriods[sortedPeriods.length - 1];

  const result = [];
  let cursor = start;

  while (cursor <= end) {
    result.push(cursor);
    cursor = nextPeriod(cursor, aggregation);
  }

  return result;
}

function nextPeriod(period, aggregation) {
  if (aggregation === 'monthly') {
    const [y, m] = period.split('-').map(Number);
    const nextM = m === 12 ? 1 : m + 1;
    const nextY = m === 12 ? y + 1 : y;
    return `${nextY}-${String(nextM).padStart(2, '0')}`;
  }

  if (aggregation === 'yearly') {
    const y = Number(period);
    return String(y + 1);
  }

  return period;
}

function assignCompanyColors(companies) {
  const uniqueCompanies = Array.from(new Set(companies));
  const companyColorMap = {};
  const saturation = 80;
  const lightness = 50;
  const hueStep = Math.floor(360 / uniqueCompanies.length);

  uniqueCompanies.forEach((company, index) => {
    const hue = (index * hueStep) % 360;
    companyColorMap[company] = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  });

  return companyColorMap;
}

function renderCompanyLegends(companyColorMap) {
  const legendDivs = document.querySelectorAll('.companyLegend');
  if (!legendDivs.length) return;

  const companies = Object.entries(companyColorMap);

  // Sort alphabetically
  companies.sort((a, b) => a[0].localeCompare(b[0]));

  // Split into two columns
  const half = Math.ceil(companies.length / 2);
  const colLeft = companies.slice(0, half);
  const colRight = companies.slice(half);

  // Build legend item HTML
  const buildColumnHTML = (column) => {
    return column.map(([name, color]) => `
      <div style="display:flex; align-items:center; gap:8px; margin:4px 0;">
        <span style="
          width:12px; 
          height:12px; 
          border-radius:50%; 
          background:${color};
          display:inline-block;
        "></span>
        <span style="font-size:14px;">${name}</span>
      </div>
    `).join('');
  };

  const leftHTML = buildColumnHTML(colLeft);
  const rightHTML = buildColumnHTML(colRight);

  // Final legend markup with header
  const legendHTML = `
    <br>
    <div style="text-align:center; margin-bottom:8px; font-size:13px;">
      <b>COMPANY LEGEND</b><br>
      Our data summaries come from data entries provided by different companies and organizations.
    </div>

    <div style="
      display:flex;
      justify-content:center;
      gap:40px;
      width:100%;
      margin:0 auto;
    ">
      <div>${leftHTML}</div>
      <div>${rightHTML}</div>
    </div>
    <br>
  `;

  // Render in all matching divs
  legendDivs.forEach(div => {
    div.innerHTML = legendHTML;
  });
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => initChartsWithAggregation('{{query.aggregation}}' || 'monthly'));
} else {
  initChartsWithAggregation('{{query.aggregation}}' || 'monthly');
}

function initChartsWithAggregation(aggregation) {
  console.log('üöÄ Initializing charts with TOTAL values (no daily averaging)...');
  
  if (typeof Chart === 'undefined') {
    console.error('‚ùå Chart.js not loaded');
    const wrapper = document.getElementById('trend-charts-wrapper');
    if (wrapper) {
      wrapper.innerHTML = '<div style="padding:2rem;text-align:center;color:#f44336;">Chart.js failed to load. Please refresh.</div>';
    }
    return;
  }
  
  console.log('‚úÖ Chart.js loaded');

  try {
    const dataEntries = {{{timeSeriesData}}};
    console.log(`üìä Received ${dataEntries ? dataEntries.length : 0} filtered data entries`);
    
    if (!dataEntries || dataEntries.length === 0) {
      console.warn('‚ö†Ô∏è No data entries available');
      const wrapper = document.getElementById('trend-charts-wrapper');
      if (wrapper) {
        wrapper.innerHTML = '<div style="padding:2rem;text-align:center;color:#999;">No data entries available for the selected filters.</div>';
      }
      return;
    }

    console.log('üìã Sample data entry:', dataEntries[0]);
    
    const regionName = '{{regionName}}';
    const provinceName = '{{provinceName}}';
    const municipalityName = '{{municipalityName}}';
    const startDate = '{{query.startDate}}' || '';
    const endDate = '{{query.endDate}}' || '';

    const sanitize = v => v && v !== 'ALL';
    const locationParts = [municipalityName, provinceName, regionName].filter(sanitize);
    const locationText = locationParts.join(', ');

    let periodText = '';
    if (startDate && endDate) {
      periodText = `from ${startDate} to ${endDate}`;
    } else if (startDate) {
      periodText = `from ${startDate}`;
    } else if (endDate) {
      periodText = `until ${endDate}`;
    }

    const chartTitleText =
      `Waste Trends${locationText ? ' for ' + locationText : ''}` +
      `${periodText ? ' ' + periodText : ''}`;
    
    const mainTitle = document.getElementById('trends-main-title');
    if (mainTitle) {
      const aggregationLabel = aggregation === 'monthly' ? 'Monthly' : 'Yearly';
      mainTitle.innerHTML = `
        <i class="fa-solid fa-chart-line" style="margin-right: 10px; color: #2196F3;"></i>
        ${chartTitleText}
        <span style="font-size: 0.9rem; color: #666; font-weight: 400; margin-left: 10px;">
          (${aggregationLabel} Totals - Proportional Distribution)
        </span>
        <select id="select-aggregation" style="margin-left: auto; width: 200px;">
          <option value="monthly" ${aggregation === 'monthly' ? 'selected' : ''}>Monthly Summary</option>
          <option value="yearly" ${aggregation === 'yearly' ? 'selected' : ''}>Yearly Summary</option>
        </select>&nbsp;
        <button class="btn-primary" id="applyBtn2">
          <i class="fa-solid fa-check"></i> Apply Filters
        </button>
      `;
      
      const applyBtn2 = document.getElementById('applyBtn2');
      if (applyBtn2) {
        applyBtn2.onclick = () => {
          const newAggregation = document.getElementById('select-aggregation').value;
          initChartsWithAggregation(newAggregation);
        };
      }
    }
    
    const aggregatedData = aggregateDataWithAveraging(dataEntries, aggregation);
    const sortedPeriods = Object.keys(aggregatedData).sort();
    const completePeriods = generateCompletePeriods(sortedPeriods, aggregation);

    console.log(`üìä Generated ${sortedPeriods.length} periods from ${dataEntries.length} data entries`);
    
    if (sortedPeriods.length === 0) {
      console.warn('‚ö†Ô∏è No periods after aggregation');
      return;
    }
    
    const labels = completePeriods.map(p => formatPeriodLabel(p, aggregation));
    
    // Use TOTAL values (not divided by days)
    const totalWeights = completePeriods.map(p =>
      aggregatedData[p] ? aggregatedData[p].totalWasteGenerated : null
    );
    const totalPerCapita = completePeriods.map(p =>
      aggregatedData[p] ? aggregatedData[p].totalPerCapita : null
    );

    // Assign company colors
    const companyNames = dataEntries.map(d => d.company_name);
    const companyColorMap = assignCompanyColors(companyNames);

    // Then, when preparing the actualData dataset:
    const actualData = completePeriods.map(p => {
      const entry = aggregatedData[p];
      return entry ? entry.totalWasteGenerated : null;
    });

    // Prepare point colors
    const pointBackgroundColors = completePeriods.map(p => {
      const entry = aggregatedData[p];
      if (!entry) return '#2196F3';
      const companies = Array.from(entry.companyNames || []);
      return companies.length <= 1 ? companyColorMap[companies[0]] || '#2196F3' : '#ffffff';
    });

    // Place numbers on points with multiple companies
    const pointLabels = completePeriods.map(p => {
      const entry = aggregatedData[p];
      if (!entry) return '';
      const companies = Array.from(entry.companyNames || []);
      return companies.length > 1 ? companies.length.toString() : '';
    });

    // Multiple company dots will display a number instead (Chart 1)
    const multiCompanyPlugin = {
      id: 'multiCompanyPlugin',
      afterDatasetsDraw(chart) {
        const { ctx } = chart;

        chart.data.datasets.forEach((dataset, datasetIndex) => {
          // Only draw for the "Actual Data (kg)" line
          if (dataset.label !== 'Actual Data (kg)') return;

          const meta = chart.getDatasetMeta(datasetIndex);

          meta.data.forEach((point, index) => {
            const entry = aggregatedData[completePeriods[index]];
            if (!entry) return;

            const companies = Array.from(entry.companyNames || []);
            if (companies.length <= 1) return; // skip single-company points

            const x = point.x;
            const y = point.y;
            const radius = 8; // same as pointRadius

            // Draw white circle
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000000';
            ctx.stroke();

            // Draw number inside
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(companies.length.toString(), x, y);
            ctx.restore();
          });
        });
      }
    };

    // Version for Chart 2
    // Custom plugin for multi-company points in Chart 2
    const multiCompanyPluginPerCapita = {
      id: 'multiCompanyPluginPerCapita',
      afterDatasetDraw(chart) {
        const { ctx } = chart;
        const datasetIndex = 0; // only the first dataset ("Total Per Capita")
        const dataset = chart.data.datasets[datasetIndex];
        const meta = chart.getDatasetMeta(datasetIndex);

        meta.data.forEach((point, index) => {
          const entry = aggregatedData[completePeriods[index]];
          if (!entry) return;

          const companies = Array.from(entry.companyNames || []);
          if (companies.length <= 1) return; // only multi-company points

          const x = point.x;
          const y = point.y;
          const radius = 8;

          // Draw white circle
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, 2 * Math.PI);
          ctx.fillStyle = '#ffffff';
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#000000';
          ctx.stroke();

          // Draw number of companies inside
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 10px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(companies.length.toString(), x, y);
          ctx.restore();
        });
      }
    };

    console.log("Aggregated data: ", aggregatedData)
    
    console.log('üìà Chart data points:', totalWeights.length);
    console.log('üìä Sample total weights (kg):', totalWeights.slice(0, 5));
    console.log('üìä Sample total per capita:', totalPerCapita.slice(0, 5));
    
    const xValues = Array.from({ length: totalWeights.length }, (_, i) => i);

    const filteredX = [];
    const filteredY = [];

    for (let i = 0; i < totalWeights.length; i++) {
      if (totalWeights[i] !== null) {
        filteredX.push(i);
        filteredY.push(totalWeights[i]);
      }
    }

    const regression = calculatePolynomialRegression(filteredX, filteredY, 3);
    console.log('üìê Regression R¬≤:', regression.rSquared);
    
    const trendValuesActual = xValues.map(x => evaluatePolynomial(regression.coefficients, x));
    
    const lastPeriod = sortedPeriods[sortedPeriods.length - 1];
    const futurePeriods = generateFutureLabels(lastPeriod, aggregation, 3);
    const futureLabels = futurePeriods.map(p => formatPeriodLabel(p, aggregation));
    const allLabels = [...labels, ...futureLabels];
    
    const futureX = [totalWeights.length, totalWeights.length + 1, totalWeights.length + 2];
    const futureY = futureX.map(x => evaluatePolynomial(regression.coefficients, x));
    
    const lastX = xValues[xValues.length - 1];
    let derivative = 0;
    for (let i = 1; i < regression.coefficients.length; i++) {
      derivative += i * regression.coefficients[i] * Math.pow(lastX, i - 1);
    }
    
    // ========== TREND ANALYSIS FOR CHART 1: TOTAL WASTE GEN TREND ==========

    const regressionStatsEl = document.getElementById('regressionStats');
    if (regressionStatsEl) {
      const directionText = derivative > 0
        ? 'an overall <b>upward (increasing) trend</b>'
        : 'an overall <b>downward (decreasing) trend</b>';

      let fitText;
      const r2 = regression.rSquared * 100;

      if (r2 >= 70) {
        fitText = `The data follows the trend line well, with about <b>${r2.toFixed(1)}%</b> consistency.`;
      } else if (r2 >= 40) {
        fitText = `The data shows a moderate amount of variation, with the trend line explaining about <b>${r2.toFixed(1)}%</b> of the pattern.`;
      } else {
        fitText = `The data is quite variable, so the trend line captures only part of the overall pattern (about <b>${r2.toFixed(1)}%</b>).`;
      }

      const projectedValue = futureY[2].toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });

      const projectionText = `If this pattern continues, the expected value by <b>${futureLabels[2]}</b> is approximately <b>${projectedValue} kg</b>.`;

      regressionStatsEl.innerHTML = `
        The analysis indicates ${directionText} over the observed periods. 
        ${fitText} 
        ${projectionText}
      `;
    }

    // ======== PER CAPITA ANALYSIS (NO REGRESSION) =========
    const perCapitaStatsEl = document.getElementById('perCapitaStats');

    if (perCapitaStatsEl && totalPerCapita.length > 0) {
      const values = totalPerCapita;
      const periods = labels;

      // Filter out nulls but keep original index mapping
      const validPoints = values
        .map((val, idx) => val !== null ? { value: val, index: idx } : null)
        .filter(Boolean);

      // If no valid data, show message
      if (validPoints.length === 0) {
        perCapitaStatsEl.innerHTML = "No valid per capita data available for analysis.";
        return;
      }

      const first = validPoints[0].value;
      const last = validPoints[validPoints.length - 1].value;

      const minPoint = validPoints.reduce((a, b) => (a.value < b.value ? a : b));
      const maxPoint = validPoints.reduce((a, b) => (a.value > b.value ? a : b));

      let directionText = '';

      if (last > first) {
        directionText = 'an overall <b>upward (increasing)</b> pattern';
      } else if (last < first) {
        directionText = 'an overall <b>downward (decreasing)</b> pattern';
      } else {
        directionText = 'a <b>generally stable</b> trend';
      }

      const paragraph = `
        The per capita values show ${directionText} across the observed periods.
        The highest recorded value is <b>${maxPoint.value.toFixed(2)}</b> during <b>${periods[maxPoint.index]}</b>,
        while the lowest is <b>${minPoint.value.toFixed(2)}</b> during <b>${periods[minPoint.index]}</b>.
        The most recent recorded value is in <b>${periods[validPoints[validPoints.length - 1].index]}</b> (<b>${last.toFixed(2)}</b>).
      `;

      perCapitaStatsEl.innerHTML = paragraph;
    }

    // ======== CATEGORY ANALYSIS (NO REGRESSION) =========
    const categoryStatsEl = document.getElementById('categoryStats');

    if (categoryStatsEl) {
      const categories = ['Biodegradable', 'Recyclable', 'Residual', 'Special/Hazardous'];

      const summaries = categories.map(cat => {
        // Extract values for this category
        const values = completePeriods.map(p => {
          const periodData = aggregatedData[p];
          return periodData?.categoryTotals?.[cat] ?? null;
        });

        // Remove nulls but keep index mapping
        const validPoints = values
          .map((val, idx) => val !== null ? { value: val, index: idx } : null)
          .filter(Boolean);

        if (validPoints.length === 0) {
          return `${cat}: No recorded data.`;
        }

        const first = validPoints[0].value;
        const last = validPoints[validPoints.length - 1].value;

        const minPoint = validPoints.reduce((a, b) => a.value < b.value ? a : b);
        const maxPoint = validPoints.reduce((a, b) => a.value > b.value ? a : b);

        let direction;
        if (last > first) direction = 'an increasing pattern';
        else if (last < first) direction = 'a decreasing pattern';
        else direction = 'a generally stable trend';

        return `
          <b>${cat}</b> shows ${direction}. 
          Its highest recorded value is <b>${
            maxPoint.value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })
          } kg</b> during <b>${labels[maxPoint.index]}</b>, 
          and its lowest is <b>${
            minPoint.value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })
          } kg</b> during <b>${labels[minPoint.index]}</b>.
        `;
      });

      categoryStatsEl.innerHTML = `
        ${summaries.join('<br><br>')}
      `;
    }
    
    // ========== CREATE CHART 1: TOTAL WASTE GENERATION ==========
    console.log('üé® Creating Chart 1: Total Waste Generation');
    
    const minWidth = 1400;
    const pixelsPerLabel = 50;
    const containerWidth = Math.max(minWidth, allLabels.length * pixelsPerLabel);
    
    const totalWasteContainer = document.getElementById('trendTotalWasteContainer');
    if (totalWasteContainer) {
      totalWasteContainer.style.width = containerWidth + 'px';
      totalWasteContainer.style.minWidth = containerWidth + 'px';
    }
    
    const totalWasteCanvas = document.getElementById('trendTotalWaste');
    if (totalWasteCanvas) {
      if (totalWasteCanvas.chartInstance) totalWasteCanvas.chartInstance.destroy();

      const ctx = totalWasteCanvas.getContext('2d');
      if (!ctx) {
        console.error('‚ùå Cannot get canvas context');
        return;
      }
      
      const lastTrendValue = evaluatePolynomial(regression.coefficients, totalWeights.length - 1);
      
      const actualData = [...totalWeights, null, null, null];
      const trendData = [...trendValuesActual, null, null, null];
      const projectedTrendData = [
        ...Array(totalWeights.length - 1).fill(null),
        lastTrendValue,
        ...futureY
      ];
      const projectedData = [
        ...Array(totalWeights.length - 1).fill(null),
        lastTrendValue,
        ...futureY
      ];
      
      totalWasteCanvas.chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: allLabels,
          datasets: [
            {
              label: 'Actual Data (kg)',
              data: actualData,
              borderColor: '#2196F3',            // line color
              pointBackgroundColor: pointBackgroundColors, // color per dot
              //pointBorderColor: '#000', // black border for white points
              pointBorderWidth: 0,
              pointRadius: 6,
              pointHoverRadius: 8,
              borderWidth: 2,
              fill: false,
              tension: 0.3,
              spanGaps: true
            },
            {
              label: 'Trend Line (Actual)',
              data: trendData,
              borderColor: '#FF5722',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 5,
              spanGaps: true
            },
            {
              label: 'Trend Line (Projected)',
              data: projectedTrendData,
              borderColor: '#FF5722',
              borderWidth: 3,
              borderDash: [8, 4],
              fill: false,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 5,
              spanGaps: true
            },
            {
              label: 'Projected Values',
              data: projectedData,
              borderColor: '#FFA000',
              backgroundColor: 'rgba(255, 160, 0, 0.15)',
              borderDash: [8, 4],
              fill: 'origin',
              tension: 0.4,
              pointRadius: 6,
              pointBackgroundColor: '#FFA000',
              pointBorderColor: '#fff',
              pointBorderWidth: 2,
              borderWidth: 3,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: { 
              position: 'top',
              labels: {
                font: { size: 12 },
                usePointStyle: true,
                padding: 15
              }
            },
            title: {
              display: true,
              text: `Total Waste Generation (${aggregation === 'monthly' ? 'Monthly' : 'Yearly'} Totals)`,
              font: { size: 14, weight: 'bold' },
              color: '#2d613f',
              padding: { top: 10, bottom: 20 }
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  if (context.parsed.y === null) return '';

                  const periodKey = completePeriods[context.dataIndex];
                  const periodData = aggregatedData[periodKey];

                  // Start with dataset value
                  const lines = [`${context.dataset.label}: ${context.parsed.y.toFixed(2)} kg`];

                  // Only add company list for the "Actual Data" dataset
                  if (context.dataset.label === 'Actual Data (kg)' && periodData && periodData.companyNames) {
                    const companyList = Array.from(periodData.companyNames);

                    if (companyList.length === 1) {
                      lines.push(`Company: ${companyList[0]}`);
                    } else if (companyList.length > 1) {
                      lines.push(`Companies (${companyList.length}):`);
                      companyList.forEach(name => lines.push(`- ${name}`));
                    }

                    // Add a blank line (space) after the company list
                    lines.push('');
                  }

                  // Add location list (same ordering as company list)
                  if (context.dataset.label === 'Actual Data (kg)' && periodData && periodData.locationNames) {
                    const locationList = Array.from(periodData.locationNames);

                    if (locationList.length === 1) {
                      lines.push(`Location: ${locationList[0]}`);
                    } else if (locationList.length > 1) {
                      lines.push(`Locations (${locationList.length}):`);
                      locationList.forEach(loc => lines.push(`- ${loc}`));
                    }

                    // Add a blank line (space) after the company list
                    lines.push('');
                  }

                  return lines;
                }
              }
            }
          },
          scales: {
            y: { 
              ticks: {
                font: { size: 11 }
              },
              title: { 
                display: true, 
                text: 'Total Waste Generation (kg)',
                font: { weight: 'bold', size: 12 }
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            },
            x: { 
              title: { 
                display: true, 
                text: `Period (${aggregation})`,
                font: { weight: 'bold', size: 12 }
              },
              ticks: { 
                maxRotation: 45, 
                minRotation: 45,
                autoSkip: true,
                font: { size: 10 }
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            }
          },
          layout: {
            padding: {
              left: 10,
              right: 30,
              top: 10,
              bottom: 10
            }
          }
        },
        plugins: [multiCompanyPlugin]
      });
      console.log('‚úÖ Chart 1 created');
    }
    
    // ========== CREATE CHART 2: TOTAL PER CAPITA ==========
    console.log('üé® Creating Chart 2: Total Per Capita');
    
    const perCapitaWidth = Math.max(1200, labels.length * 100);
    const perCapitaContainer = document.getElementById('trendPerCapitaContainer');
    if (perCapitaContainer) {
      perCapitaContainer.style.width = perCapitaWidth + 'px';
      perCapitaContainer.style.minWidth = perCapitaWidth + 'px';
    }
    
    const perCapitaCanvas = document.getElementById('trendPerCapita');
    if (perCapitaCanvas) {
      if (perCapitaCanvas.chartInstance) perCapitaCanvas.chartInstance.destroy();

      perCapitaCanvas.chartInstance = new Chart(perCapitaCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Total Per Capita',
            data: totalPerCapita,
            borderColor: '#FF9800',
            backgroundColor: 'rgba(255, 152, 0, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 6,
            pointBackgroundColor: pointBackgroundColors,
            pointBorderWidth: 0,
            borderWidth: 3,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: { position: 'top' },
            title: {
              display: true,
              text: `Total Per Capita (${aggregation === 'monthly' ? 'Monthly' : 'Yearly'} Totals)`,
              font: { size: 14, weight: 'bold' },
              color: '#2d613f'
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  if (context.parsed.y === null) return '';
                  const periodKey = completePeriods[context.dataIndex];
                  const periodData = aggregatedData[periodKey];

                  const lines = [
                    `Total Per Capita: ${context.parsed.y.toFixed(2)}`,
                    //periodData ? `From ${periodData.entryCount.toFixed(2)} entries` : ''
                  ];

                  // Add company or list of companies
                  if (periodData && periodData.companyNames) {
                    const companyList = Array.from(periodData.companyNames);

                    if (companyList.length === 1) {
                      lines.push(`Company: ${companyList[0]}`);
                    } else if (companyList.length > 1) {
                      lines.push(`Companies (${companyList.length}):`);
                      companyList.forEach(name => lines.push(`- ${name}`));
                    }

                    lines.push('')
                  }

                  // Add company or list of companies
                  if (periodData && periodData.locationNames) {
                    const locationList = Array.from(periodData.locationNames);

                    if (locationList.length === 1) {
                      lines.push(`Location: ${locationList[0]}`);
                    } else if (locationList.length > 1) {
                      lines.push(`Locations (${locationList.length}):`);
                      locationList.forEach(name => lines.push(`- ${name}`));
                    }

                    lines.push('')
                  }

                  return lines;
                }
              }
            }
          },
          scales: {
            y: {
              title: { display: true, text: 'Total Per Capita' },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            },
            x: {
              title: { display: true, text: `Period (${aggregation})` },
              ticks: { maxRotation: 45, minRotation: 45, autoSkip: true, font: { size: 10 } },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            }
          },
          layout: {
            padding: { left: 10, right: 30, top: 10, bottom: 10 }
          }
        },
        plugins: [multiCompanyPluginPerCapita]
      });

      console.log('‚úÖ Chart 2 created');
    }
    
    // ========== CREATE CHART 3: WASTE BY CATEGORY ==========
    console.log('üé® Creating Chart 3: Waste by Category');

    const categoryCanvas = document.getElementById('trendByCategory');
    if (categoryCanvas) {
      const categories = ['Biodegradable', 'Recyclable', 'Residual', 'Special/Hazardous'];
      const categoryColors = {
        'Biodegradable': 'rgba(76, 175, 80, 0.6)',
        'Recyclable': 'rgba(33, 150, 243, 0.6)',
        'Residual': 'rgba(158, 158, 158, 0.6)',
        'Special/Hazardous': 'rgba(244, 67, 54, 0.6)'
      };

      if (categoryCanvas.chartInstance) categoryCanvas.chartInstance.destroy();

      // Plugin for multi-company periods
      const multiCompanyPlugin = {
        id: 'multiCompanyPlugin',
        afterDatasetDraw(chart) {
          const { ctx, data } = chart;

          data.datasets.forEach((dataset, datasetIndex) => {
            const meta = chart.getDatasetMeta(datasetIndex);

            meta.data.forEach((point, index) => {
              const entry = aggregatedData[completePeriods[index]];
              if (!entry) return;

              const companies = Array.from(entry.companyNames || []);
              if (companies.length <= 1) return; // only multi-company points

              const x = point.x;
              const y = point.y;
              const radius = 6;

              // Draw white circle
              ctx.save();
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, 2 * Math.PI);
              ctx.fillStyle = '#ffffff';
              ctx.fill();
              ctx.lineWidth = 2;
              ctx.strokeStyle = '#000000';
              ctx.stroke();

              // Draw number of companies inside
              ctx.fillStyle = '#000000';
              ctx.font = 'bold 10px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(companies.length.toString(), x, y);
              ctx.restore();
            });
          });
        }
      };

      // Build dataset for chart
      const categoryDatasets = categories.map(cat => {
        const data = completePeriods.map(p => {
          const periodData = aggregatedData[p];
          return periodData?.categoryTotals?.[cat] ?? null;
        });

        return {
          label: cat,
          data,
          // Keep border fully opaque
          borderColor: categoryColors[cat].replace(/0\.\d+/, '1'), 
          borderWidth: 2,
          fill: false,
          tension: 0.3,
          pointBackgroundColor: pointBackgroundColors,
          pointBorderWidth: 0,
          pointRadius: 5,
          pointHoverRadius: 7,
          spanGaps: true
        };
      });

      // Build chart 3
      categoryCanvas.chartInstance = new Chart(categoryCanvas.getContext('2d'), {
        type: 'line',
        data: { labels: labels, datasets: categoryDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: {
              position: 'top',
              labels: {
                generateLabels: chart => {
                  return chart.data.datasets.map((dataset, i) => ({
                    text: dataset.label,
                    fillStyle: dataset.borderColor,   // use border color
                    strokeStyle: dataset.borderColor, // optional, same as border
                    lineWidth: dataset.borderWidth,
                    hidden: !chart.isDatasetVisible(i),
                    datasetIndex: i
                  }));
                }
              }
            },
            title: {
              display: true,
              text: `Waste by Category (${aggregation === 'monthly' ? 'Monthly' : 'Yearly'} Totals)`,
              font: { size: 14, weight: 'bold' },
              color: '#2d613f'
            },
            tooltip: {
              callbacks: {
                title: ctx => `Period: ${ctx[0].label}`,
                label: ctx => {
                  const dataset = ctx.dataset;
                  const value = ctx.parsed.y ?? 0;
                  return `${dataset.label}: ${value.toFixed(2)} kg`;
                },
                afterBody: ctx => {
                  const period = completePeriods[ctx[0].dataIndex];
                  const periodData = aggregatedData[period];
                  if (!periodData) return '';

                  const companies = Array.from(periodData.companyNames || []);
                  const locations = Array.from(periodData.locationNames || []);

                  const lines = [];

                  lines.push('')

                  // Companies block
                  if (companies.length === 1) {
                    lines.push(`Company: ${companies[0]}`);
                  } else if (companies.length > 1) {
                    lines.push(`Companies (${companies.length}):`);
                    companies.forEach(c => lines.push(`- ${c}`));
                  }
                  lines.push('')

                  // Locations block (added)
                  if (locations.length === 1) {
                    lines.push(`Location: ${locations[0]}`);
                  } else if (locations.length > 1) {
                    lines.push(`Locations (${locations.length}):`);
                    locations.forEach(l => lines.push(`- ${l}`));
                  }

                  return lines;
                },
                labelColor: ctx => {
                  // Use the dataset's border color instead of backgroundColor
                  return {
                    borderColor: ctx.dataset.borderColor,
                    backgroundColor: ctx.dataset.borderColor
                  };
                }
              }
            }
          },
          scales: {
            y: { stacked: false, title: { display: true, text: 'Total Weight (kg)' } },
            x: {
              stacked: false,
              title: { display: true, text: `Period (${aggregation})` },
              ticks: { maxRotation: 45, minRotation: 45, autoSkip: true, font: { size: 10 } }
            }
          }
        },
        plugins: [multiCompanyPlugin]
      });

      console.log('‚úÖ Chart 3 created');
    }
    
    renderCompanyLegends(companyColorMap);
    console.log('‚úÖ All charts initialized successfully');
    
  } catch (error) {
    console.error('‚ùå Error initializing charts:', error);
    console.error('Stack:', error.stack);
  }
}
</script>

<!-- Pie chart script -->
<script>

const summaryData = {{{summaryPieData}}},
      detailedData = {{{detailedPieData}}},
      barChartData = {{{barChartData}}},
      sectorBarData = {{{sectorBarData}}},
      sectorPieData = {{{sectorPieData}}};

const supertypeDemo = {{{supertypeDemo}}};
const grandTotal = {{{grandTotal}}};

const rand = arr => arr[Math.floor(Math.random() * arr.length)];
const pct = (value, total) => total ? (value / total * 100) : 0;
const fmtKg = (n) => `${Number(n).toFixed(3)} kg`;

const overallPhrases = {
  balanced:
    "All major categories are nearly proportional, indicating a balanced waste composition with no single dominant source.<br><br>",
  dominant:
    "One category dominates the waste stream. Prioritize source reduction and targeted segregation for this category.<br><br>",
  lowReported:
    "Some categories show very low or missing volumes. This may be caused by underreporting, misclassification, gaps in reporting, or genuinely low output.<br><br>",
  mixedDominant:
    "Several categories contribute significant amounts. Consider combined campaigns (e.g., recycling + organics) rather than programs for a single type.<br><br>"
};

const overallRecommendations = {
  Biodegradable: "Enhance composting initiatives and promote household segregation of organics.",
  Recyclable: "Expand recycling collection routes and promote local recycling markets.",
  Residual: "Reduce single-use packaging as much as possible. Encourage proper containment of sanitary waste and explore recovery options (e.g., co-processing) for non-recyclables like wrappers, textiles, and ceramics.",
  "Special/Hazardous": "Implement safe collection and disposal protocols, raise awareness on proper handling, and coordinate with authorized hazardous waste facilities."
};

function generateOverallInsight(supertypeMapObj, grandTotalVal) {
  const supertypes = Object.values(supertypeMapObj);
  const nonzero = supertypes.filter(s => Number(s.totalWeight) > 0);
  const shares = supertypes.map(s => ({
    name: s.name,
    value: Number(s.totalWeight),
    pct: pct(Number(s.totalWeight), grandTotalVal)
  }));
  shares.sort((a,b)=>b.pct-a.pct);

  if (grandTotalVal === 0) {
    return "No waste data recorded for this entry. Please verify and recheck data submissions.";
  }

  const top = shares[0];
  const second = shares[1] || null;
  const avgPct = shares.reduce((a,b)=>a+b.pct,0)/shares.length;
  const deviations = shares.map(s => Math.abs(s.pct - avgPct));
  const allBalanced = deviations.every(d => d < 5);

  const lowList = shares.filter(s => s.pct < 2).map(s => s.name);
  const tinyList = shares.filter(s => s.pct < 10).map(s => s.name);

  const fullBreakdown = shares.map(s => `${s.name}: ${s.pct.toFixed(1)}%`).join(', ');

  let insightText = "";
  let recHTML = "";

  if (allBalanced && nonzero.length > 2) {
    insightText = overallPhrases.balanced;
    if (lowList.length) insightText += ` However, some categories appear minimal: ${lowList.join(', ')}.`;
    if (tinyList.length === 1) insightText += ` The category ${tinyList[0]} is noticeably small compared to others.`;
  }

  else if (top.pct >= 50) {
    insightText = `${overallPhrases.dominant} Currently, <strong>${top.name}</strong> represents ${top.pct.toFixed(1)}% of the total.`;
    if (lowList.length) insightText += ` Some low categories: ${lowList.join(', ')}.`;
    if (tinyList.length === 1) insightText += ` The category ${tinyList[0]} is noticeably small compared to others.`;

    if (overallRecommendations[top.name]) {
      recHTML = `
        <div class="recommendation-box">
        <span>
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <b style='color:#2d613f;'>${top.name.toUpperCase()}</b><br>
          ${overallRecommendations[top.name]}
        </span>
        </div>
      `;
    }
  }

  else if (shares.filter(s => s.pct >= 20).length >= 2 &&
         shares.filter(s => s.pct >= 20).length <= 3) {
    const strongList = shares.filter(s => s.pct >= 20);
    insightText = `${overallPhrases.mixedDominant} <b>Major categories: ${strongList.map(s => s.name).join(', ')}</b>`;

    recHTML = strongList
      .filter(s => overallRecommendations[s.name])
      .map(s => `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
          <b style='color:#2d613f;'>${s.name.toUpperCase()}</b><br>
          ${overallRecommendations[s.name]}
          </span>
        </div>
      `)
      .join('');
  }

  else if (lowList.length === shares.length) {
    insightText = "All categories show minimal values; likely incomplete or unreported data.";
  }

  else if (lowList.length) {
    insightText = `${overallPhrases.lowReported} Notably low: ${lowList.join(', ')}.`;
  }

  else {
    const uniquePattern = new Set(shares.map(s => Math.round(s.pct / 5) * 5)).size === shares.length;
    if (uniquePattern && !allBalanced && top.pct < 50) {
      insightText = "Each category has a distinct share, showing a varied waste composition with no single type dominating.";
      if (tinyList.length) insightText += ` The category ${tinyList.join(', ')} has smaller proportions than others.`;
    } else {
      insightText = "The waste composition shows a mixed pattern without extreme concentrations. Continue tracking for shifts over time.";
    }
  }

  return `${insightText}${recHTML}`;
}

function generateSupertypeInsight(supertypeObj, grandTotalVal) {
  const types = supertypeObj.types || [];
  const total = Number(supertypeObj.totalWeight) || 0;
  if (!total || !types.length) {
    return `No data recorded for <strong>${supertypeObj.name}</strong>. Verify reporting for this category.`;
  }

  const pairs = types.map(t => ({
    name: t.name,
    value: Number(t.weight) || 0
  })).sort((a, b) => b.value - a.value);

  const top = pairs[0];
  const second = pairs[1] || null;
  const avgVal = pairs.reduce((a, b) => a + b.value, 0) / pairs.length;
  const allBalanced = pairs.every(p => Math.abs(p.value - avgVal) < avgVal * 0.05);
  const lowList = pairs.filter(p => p.value < avgVal * 0.2).map(p => p.name);
  const highList = pairs.filter(p => p.value >= avgVal * 1.2);

  const recs = {
    Biodegradable: {
      "Food / Kitchen Waste": "Promote household and commercial composting, and encourage portion control to minimize food waste.",
      "Agricultural Waste": "Encourage conversion into compost or animal feed.",
      "Animal / Livestock Waste": "Implement safe manure management where feasible.",
      "Garden / Park Waste": "Set up community composting areas or mulching programs.",
      "Vegetable and Fruit Peelings": "Encourage home composting and segregation from residuals.",
      "Other (Biodegradable)": "Ensure clear segregation and consider composting methods or biomass processing."
    },
    Recyclable: {
      "Polyethylene Terephthalate (PET)": "Enhance PET bottle collection drives and link with recycling facilities.",
      "Office Paper": "Encourage adoption of paperless systems.",
      "Corrugated Cardboard": "Encourage reuse for packaging and bulk recycling in business establishments.",
      "Glass": "Set up collection for glass containers and support bottle return programs.",
      "Newspaper": "Encourage reuse or bulk recycling, especially from offices and stores.",
      "Polyvinyl Chloride (PVC)": "Coordinate with accredited recyclers; discourage open burning.",
      "Polypropylene (PP)": "Support sorting programs to recover PP plastics (e.g., bottle caps, containers).",
      "Aluminum": "Promote aluminum recycling; used metals may be molten and reused for production of cans, car parts, or construction materials.",
      "High-density polyethylene (HDPE)": "Facilitate recovery and proper cleaning for reuse or recycling.",
      "Tin Cans": "Encourage collection through metal recyclers; avoid disposal with residual waste.",
      "Low-density polyethylene (LDPE)": "Minimize single-use plastics; promote use of thicker, reusable alternatives.",
      "Polystyrene (PS)": "Discourage styrofoam use and support recycling alternatives.",
      "Other (Recyclable)": "Clarify labeling and strengthen material recovery facility (MRF) sorting."
    },
    Residual: {
      "Wrappers / Sachets": "Advocate for reduction of single-use plastics.",
      "Sanitary Napkins / Diapers": "Enforce proper segregation and explore biodegradable alternatives.",
      "Textiles / Fabrics": "Encourage clothing donation or repurposing; reduce textile waste.",
      "Rubber": "Coordinate with facilities that repurpose or process rubber materials.",
      "Ceramics": "Promote reuse in construction filler applications or proper disposal.",
      "Other (Residual)": "Focus on waste reduction at source and explore alternative disposal technologies."
    },
    "Special/Hazardous": {
      "Healthcare Waste": "Ensure collection and treatment through accredited hazardous waste handlers.",
      "Bulky Waste": "Coordinate scheduled pickup or reuse programs for furniture and appliances.",
      "Tires": "Explore reuse for playground or construction materials; avoid open burning.",
      "Paints / Thinners": "Handle as hazardous; ensure separate storage and disposal.",
      "Oil": "Encourage oil recycling or proper collection by accredited facilities. Used oil can be re-refined into lubricants, fuel, and raw materials for petrochemical industries.",
      "Consumer Electronics / Black Goods": "Establish e-waste collection drives and proper recycling channels.",
      "Household Appliances / White Goods": "Coordinate with repair/reuse programs and e-waste recyclers.",
      "Household Batteries": "Promote safe collection points for used batteries.",
      "Other (Special / Hazardous)": "Promote segregation, labeling, and proper disposal."
    }
  };

  const getRecommendation = (dominantList, supertype) => {
    const rset = recs[supertype] || {};
    const blocks = dominantList
      .map(t => {
        const recText = rset[t.name];
        if (!recText) return null;
        return `
          <div class="recommendation-box">
            <span>
              <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
              <b style='color:#2d613f;'>${t.name.toUpperCase()}</b><br>
              ${recText}
            </span>
          </div>
        `;
      })
      .filter(Boolean)
      .join("");
    return blocks ? `<br>${blocks}` : "";
  };

  if (allBalanced) {
    let text = `Types under <strong>${supertypeObj.name}</strong> have nearly equal distribution.`;
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  if (second && top.value >= second.value * 1.5) {
    let text = `<strong>${top.name}</strong> dominates this category (${top.value.toFixed(1)} kg).`;
    text += getRecommendation([top], supertypeObj.name);
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  const topTwoAvg = (top.value + (second?.value || 0)) / 2;
  if (
    pairs.length >= 2 &&
    top.value >= avgVal * 1.2 &&
    second.value >= avgVal * 1.2 &&
    top.value / second.value < 1.3
  ) {
    let text = `Two main types lead in ${supertypeObj.name}: <b>${top.name}</b> (${top.value.toFixed(1)} kg) and <b>${second.name}</b> (${second.value.toFixed(1)} kg).`;
    text += getRecommendation([top, second], supertypeObj.name);
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  if (highList.length >= 3 && highList.length < pairs.length) {
    let text = `Several types stand out within ${supertypeObj.name}: <b>${highList.map(p => p.name).join(', ')}</b>.`;
    text += getRecommendation(highList, supertypeObj.name);
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  if (lowList.length && lowList.length >= pairs.length - 1) {
    return `Most types under <strong>${supertypeObj.name}</strong> are minimal. This may be caused by low generation or incomplete entries (${lowList.join(', ')}).`;
  }

  return `The <strong>${supertypeObj.name}</strong> category shows varied distribution across its types.`;
}

function generateSectorInsight(sectorName, pieDataForSector, sectorTotalValue, grandTotalVal) {
  const labels = pieDataForSector.labels || [];
  const data = pieDataForSector.data || [];
  const pairs = labels.map((l,i) => ({
    label: l,
    value: data[i],
    pct: pct(data[i], sectorTotalValue)
  }));
  pairs.sort((a,b)=>b.pct-a.pct);

  if (sectorTotalValue === 0) {
    return `${sectorName} has no recorded waste. Please check reporting completeness.`;
  }

  const formatList = arr => {
    if (!arr.length) return '';
    const bolded = arr.map(l => `<b>${l}</b>`);
    if (bolded.length === 1) return bolded[0];
    if (bolded.length === 2) return `${bolded[0]} and ${bolded[1]}`;
    return `${bolded.slice(0, -1).join(', ')}, and ${bolded[bolded.length - 1]}`;
  };

  const avgPct = pairs.reduce((a,b)=>a+b.pct,0)/pairs.length;
  const allBalanced = pairs.every(p => Math.abs(p.pct - avgPct) < 5);
  const top = pairs[0];
  const second = pairs[1] || null;
  const lowList = pairs.filter(p => p.pct < 2).map(p => p.label);
  const tinyList = pairs.filter(p => p.pct < 10).map(p => p.label);

  let insight = '';
  let recHTML = '';

  if (allBalanced && pairs.length > 2) {
    insight = `Waste in the ${sectorName} sector is evenly distributed among all categories.`;
    if (lowList.length) insight += ` However, some categories appear minimal: ${formatList(lowList)}.`;
    if (tinyList.length === 1) insight += ` The ${formatList(tinyList)} category is noticeably small compared to others.`;
  }

  else if (top.pct >= 50) {
    insight = `<b>${top.label}</b> dominates waste generation in the ${sectorName} sector (${top.pct.toFixed(1)}%).`;
    if (lowList.length) insight += ` Other categories remain minimal: ${formatList(lowList)}.`;
    if (tinyList.length === 1) insight += ` The category ${formatList(tinyList)} shows an especially small share.`;

    if (overallRecommendations[top.label]) {
      recHTML = `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style='color:#2d613f;'>${top.label.toUpperCase()}</b><br>
            ${overallRecommendations[top.label]}
          </span>
        </div>
      `;
    }
  }

  else if (pairs.filter(p => p.pct >= 20).length >= 2 && pairs.filter(p => p.pct >= 20).length < pairs.length) {
    const majors = pairs.filter(p => p.pct >= 20).map(p => p.label);
    insight = `Dominant waste types in the ${sectorName} sector are ${formatList(majors)}, sharing most of the total volume.`;
    if (lowList.length) insight += ` Smaller portions are seen in ${formatList(lowList)}.`;
    if (tinyList.length === 1) insight += ` The category ${formatList(tinyList)} has a noticeably small share.`;

    recHTML = majors
      .filter(l => overallRecommendations[l])
      .map(l => `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style='color:#2d613f;'>${l.toUpperCase()}</b><br>
            ${overallRecommendations[l]}
          </span>
        </div>
      `)
      .join('');
  }

  else if (lowList.length === pairs.length) {
    insight = `All categories in the ${sectorName} sector show minimal proportions. This may indicate incomplete or underreported data.`;
  } else if (lowList.length) {
    insight = `Most waste types in the ${sectorName} sector have relatively low proportions. Notably low: ${formatList(lowList)}.`;
  }

  else {
    const uniquePattern = new Set(pairs.map(p => Math.round(p.pct / 5) * 5)).size === pairs.length;
    if (uniquePattern && !allBalanced && top.pct < 50) {
      insight = `Waste distribution in the ${sectorName} sector varies across all categories with no clear dominant type.`;
      if (tinyList.length) insight += ` The category ${formatList(tinyList)} appears smaller in comparison.`;
    } else {
      insight = `The ${sectorName} sector shows a mixed pattern across categories without clear extremes.`;
      if (tinyList.length) insight += ` ${formatList(tinyList)} remains relatively small.`;
    }
  }

  return `${insight}${recHTML}`;
}

function generateSectorOverviewInsight(sectorBarArr, grandTotalVal) {
  const validSectors = (sectorBarArr || []).filter(s => Number(s.value) > 0);
  if (!validSectors.length || grandTotalVal === 0) {
    return "No sector data recorded. Please verify that sector totals were generated correctly.";
  }

  const pct = (v, t) => (t ? (v / t) * 100 : 0);

  const shares = validSectors.map(s => ({
    name: s.label,
    value: Number(s.value),
    pct: pct(Number(s.value), grandTotalVal)
  })).sort((a, b) => b.pct - a.pct);

  const top = shares[0];
  const second = shares[1] || null;
  const topPct = top ? top.pct : 0;
  const lowList = shares.filter(s => s.pct < 2).map(s => s.name);
  const avgPct = shares.reduce((a, b) => a + b.pct, 0) / shares.length;
  const allBalanced = shares.every(s => Math.abs(s.pct - avgPct) < 5);

  let insight = "";
  let recHTML = "";

  const sectorRecommendations = {
    Residential: "Focus on household waste segregation, composting, and localized recycling programs.",
    Commercial: "Promote waste audits for establishments and enforce segregation-at-source policies in markets, restaurants, and shops.",
    Institutional: "Integrate waste reduction and segregation practices in offices, schools, and government facilities.",
    Industrial: "Encourage waste minimization and proper handling of industrial by-products.",
    "Agriculture and Livestock": "Support composting, manure management, and proper segregation of agricultural residue.",
    Health: "Ensure proper segregation of biomedical waste and coordinate with authorized hazardous waste treatment facilities."
  };

  if (grandTotalVal === 0) {
    return "No waste totals found. Cannot determine sector distribution.";
  }

  if (allBalanced && shares.length >= 3) {
    return "Waste generation is fairly balanced across sectors; no single area stands out as dominant.";
  }

  if (topPct >= 50) {
    insight = `<strong>${top.name}</strong> is the largest contributor, producing ${top.pct.toFixed(1)}% of all recorded waste.`;
    if (lowList.length) insight += ` Sectors with low generation include <b>${lowList.join(', ')}</b>.`;

    if (sectorRecommendations[top.name]) {
      recHTML = `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style="color:#2d613f;">${top.name.toUpperCase()}</b><br>
            ${sectorRecommendations[top.name]}
          </span>
        </div>
      `;
    }

    return `${insight}${recHTML}`;
  }

  if (topPct >= 30 && topPct < 50 && second && Math.abs(top.pct - second.pct) < 10) {
    const majorSectors = shares.filter(s => s.pct >= 30);
    insight = `Waste generation is shared across multiple sectors, led by ${majorSectors.map(s => `<strong>${s.name}</strong>`).join(' and ')}.`;
    if (lowList.length) insight += ` Some smaller sectors include <b>${lowList.join(', ')}</b>.`;

    recHTML = majorSectors
      .filter(s => sectorRecommendations[s.name])
      .map(s => `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style="color:#2d613f;">${s.name.toUpperCase()}</b><br>
            ${sectorRecommendations[s.name]}
          </span>
        </div>
      `)
      .join('');

    return `${insight}${recHTML}`;
  }

  const isGradual = shares.every((s, i, arr) => !i || arr[i - 1].pct - s.pct < 8);
  if (isGradual && !allBalanced && shares.length > 3) {
    insight = `A gradual decline in waste generation is observed across sectors, with <b>${top.name}</b> contributing the most and <b>${shares[shares.length - 1].name}</b> the least.`;
    if (lowList.length) insight += ` Some sectors have minimal values such as <b>${lowList.join(', ')}</b>.`;
    
    if (sectorRecommendations[top.name]) {
      recHTML = `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style="color:#2d613f;">${top.name.toUpperCase()}</b><br>
            ${sectorRecommendations[top.name]}
          </span>
        </div>
      `;
    }

    return `${insight}${recHTML}`;
  }

  const hasSteps = shares.some((s, i) => i && shares[i - 1].pct - s.pct >= 10);
  if (hasSteps && !isGradual) {
    insight = `Waste generation by sector follows a stepped pattern where certain sectors contribute significantly more than others.`;
    if (lowList.length) insight += ` The smallest contributors are <b>${lowList.join(', ')}</b>.`;
    return insight;
  }

  if (lowList.length) {
    return `Some sectors show minimal contribution (below 2%): <b>${lowList.join(', ')}</b>.`;
  }

  return "Sector contributions appear proportionate. Continue monitoring to identify future trends.";
}

function insertOverallInsight() {
  try {
    const overallText = generateOverallInsight(supertypeDemo || {}, Number(grandTotal || 0));
    const container = document.getElementById('summary-insight');

    if (container) {
      let box = container.querySelector('.insight-box.overall');
      if (!box) {
        box = document.createElement('div');
        box.className = 'insight-box overall';
        box.style = 'margin-top:1rem; padding:1rem; border-left:4px solid #2e7d32;background:#f7fff8; border-radius:6px;';
        container.appendChild(box);
      }
      box.innerHTML = `<h3 style="margin:0 0 0.25rem 0;color:#2d613f">Quick Recommendation</h3><div>${overallText}</div>`;
    }
  } catch (err) {
    console.error('Overall insight generation failed', err);
  }
}

function insertPerSupertypeInsights() {
  try {
    const superMap = supertypeDemo || {};
    for (const sv of Object.values(superMap)) {
      const id = sv.name.replace(/\s+/g, '');
      const wrapper = document.getElementById(id);

      if (!wrapper) continue;

      let box = wrapper.querySelector('.bar-description');
      if (!box) {
        box = document.createElement('div');
        wrapper.appendChild(box);
      }
      box.innerHTML = `<h3 style="margin:0 0 0.25rem 0;color:#2d613f">${sv.name}</h3><div>${generateSupertypeInsight(sv, Number(grandTotal || 0))}</div>`;
    }
  } catch (err) { console.error(err); }
}

function insertSectorInsights() {
  try {
    for (const [sectorName, pieData] of Object.entries(sectorPieData || {})) {
      const id = sectorName.replace(/\s+/g, '');
      const wrapper = document.getElementById(id);

      if (!wrapper) continue;
      let box = wrapper.querySelector('.sector-pie-desc');

      if (!box) {
        box = document.createElement('div');
        wrapper.appendChild(box);
      }
      const sectorTotalVal = (sectorBarData || []).find(s=>s.label===sectorName)?.value || 0;
      box.innerHTML = `<h3 style="margin:0 0 0.25rem 0;color:#2d613f">Sector Insights</h3><div>${generateSectorInsight(sectorName, pieData, Number(sectorTotalVal || 0), Number(grandTotal || 0))}</div>`;
    }
  } catch (err) { console.error(err); }
}

function insertSectorOverviewInsight() {
  try {
    const container = document.getElementById('sector-insight');
    if (!container) return;

    const insightText = generateSectorOverviewInsight(sectorBarData || [], Number(grandTotal || 0));
    
    let box = container.querySelector('.sector-overview');
    if (!box) {
      box = document.createElement('div');
      box.className = 'sector-overview';
      box.style = 'margin-top:1rem; padding:1rem; border-left:4px solid #2e7d32;background:#f7fff8; border-radius:6px;';
      container.appendChild(box);
    }

    box.innerHTML = `
      <h3 style="margin:0 0 0.25rem 0;color:#2d613f">Sector Overview</h3>
      <div>${insightText}</div>
    `;
  } catch (err) {
    console.error('Sector overview insight generation failed', err);
  }
}

let currentMode = 'summary';
const ctx = document.getElementById('supertypePieChart').getContext('2d');

const baseWidth = 600;
const baseHeight = 600;
const detailedExtraHeight = 250;

const createPieChart = (data, mode) => {
  const canvas = document.getElementById('supertypePieChart');
  canvas.width = baseWidth;
  canvas.height = mode === 'detailed'
    ? baseHeight + detailedExtraHeight
    : baseHeight;

  return new Chart(canvas.getContext('2d'), {
    type: 'pie',
    data: {
      labels: data.labels,
      datasets: [{
        data: data.data,
        backgroundColor: data.backgroundColor,
        hoverOffset: 20
      }]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          callbacks: {
            label: ({ raw, label, chart }) => {
              const total = chart._metasets[0].total || 1;
              const percent = ((raw / total) * 100).toFixed(3);
              return `${label}: ${Number(raw).toFixed(3)} kg (${percent}%)`;
            }
          }
        },
        legend: {
          display: mode === 'detailed',
          position: 'bottom',
          labels: {
            boxWidth: 20,
            padding: 10
          }
        },
        title: { display: false }
      },
      layout: {
        padding: {
          bottom: mode === 'detailed' ? detailedExtraHeight - 100 : 0
        }
      },
      cutout: 0,
      radius: mode === 'summary' ? '80%' : '100%'
    },
    plugins: [{
      id: 'multiColumnLegend',
      afterUpdate(chart) {
        const chartArea = chart.chartArea;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2 - (mode === 'detailed' ? 60 : 0); 
        chart._metasets.forEach(meta => {
          meta.controller.outerRadius = meta.controller.chart.radius;
          meta.controller.chartArea = chartArea;
          meta.controller.xCenter = centerX;
          meta.controller.yCenter = centerY;
        });

        if (mode !== 'detailed') return;

        const legend = chart.legend;
        if (!legend) return;

        const items = legend.legendItems;
        const mid = Math.ceil(items.length / 2);
        const firstCol = items.slice(0, mid);
        const secondCol = items.slice(mid);

        legend.draw = function() {
          const ctx = chart.ctx;
          const font = Chart.helpers.toFont(legend.options.labels.font);
          ctx.font = font.string;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';

          const lineHeight = font.lineHeight + 6;
          const colSpacing = chart.width / 2.5;
          const startY = chart.chartArea.bottom + 30;
          const legendLeftMargin = 60;

          const drawColumn = (col, x) => {
            col.forEach((item, i) => {
              const y = startY + i * lineHeight;
              ctx.fillStyle = item.fillStyle;
              ctx.fillRect(x, y - 5, 12, 12);
              ctx.fillStyle = item.textColor;
              ctx.fillText(item.text, x + 18, y + 2);
            });
          };

          drawColumn(firstCol, chart.chartArea.left + legendLeftMargin);
          drawColumn(secondCol, chart.chartArea.left + colSpacing + legendLeftMargin);
        };
      }
    }]
  });
};

let chart = createPieChart(summaryData, 'summary');

const togglePieBtn = document.getElementById('togglePieBtn');
if (togglePieBtn) {
  togglePieBtn.addEventListener('click', () => {
    chart.destroy();
    currentMode = currentMode === 'summary' ? 'detailed' : 'summary';
    chart = createPieChart(
      currentMode === 'summary' ? summaryData : detailedData,
      currentMode
    );
    togglePieBtn.innerHTML = currentMode === 'summary'
      ? '<i class="fa-solid fa-circle-info"></i>&nbsp; Show Detailed Pie Chart'
      : '<i class="fa-solid fa-chart-pie"></i>&nbsp; Back to Summary Pie Chart';
  });
}

const createLegendHTML = (legendData, dataset) => {
  const total = dataset.reduce((a, b) => a + b, 0);
  return legendData
    .filter(item => item.value > 0)
    .map(item => {
      const pct = total ? ((item.value / total) * 100).toFixed(3).replace(/\.0+$/, '') : '0';
      return `<span class="legend-item" style="background-color: ${item.color}">
        <span class="bar-legend-name">
          ${item.label}
          <span class="bar-legend-perc">${pct}%</span>
        </span>
        <span class="bar-legend-kg">
          ${item.value.toFixed(3)} kg
        </span>
      </span>`;
    }).join('');
};

// ========== BAR CHARTS BY WASTE TYPE ========== //
const container = document.getElementById('bar-charts-container');

for (const [supertype, chartData] of Object.entries(barChartData)) {
  const tabDiv = document.createElement('div');
  tabDiv.id = supertype.replace(/\s+/g, '');
  tabDiv.classList.add('bar-tabcontent');
  tabDiv.setAttribute('data-section', `types-${supertype.toLowerCase()}`);

  const headerDiv = document.createElement('div');
  headerDiv.classList.add('bar-header');
  headerDiv.innerHTML = `
    <h2 class="bar-legend-title">Top ${supertype} Waste Types</h2>
    <div class="bar-description" 
         style="background-color: #eef8f2; padding: 1rem; border-radius: 12px;
                border-left: 6px solid #4CAF50; margin-bottom: 1rem; width: 100%;
                box-sizing: border-box;">
    </div>
  `;

  const chartDiv = document.createElement('div');
  chartDiv.classList.add('bar-chart-wrapper');
  chartDiv.style.cssText = 'display: flex; justify-content: center; align-items: center; margin-bottom: 1.5rem;';

  const canvas = document.createElement('canvas');
  canvas.id = `barChart-${supertype.replace(/\s+/g, '-')}`;
  canvas.classList.add('bar-canvas');
  canvas.style.marginBottom = '0';

  chartDiv.appendChild(canvas);

  const legendDiv = document.createElement('div');
  legendDiv.classList.add('bar-legend-container');
  legendDiv.style.cssText = `
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: flex-start;
    justify-content: center;
  `;
  legendDiv.innerHTML = createLegendHTML(chartData.legend, chartData.data);

  tabDiv.append(headerDiv, chartDiv, legendDiv);
  container.appendChild(tabDiv);

  new Chart(canvas.getContext('2d'), {
    type: 'bar',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: `${supertype} Waste Types`,
        data: chartData.data,
        backgroundColor: chartData.legend.map(i => i.color)
      }]
    },
    options: {
      animation: { duration: 0 },
      responsive: true,
      indexAxis: 'x',
      plugins: {
        tooltip: {
          callbacks: {
            label: ({ parsed }) => `${parsed.y.toFixed(3)} kg`
          }
        },
        title: { display: false }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Weight (kg)' }
        },
        x: {
          ticks: { autoSkip: false, maxRotation: 45, minRotation: 20 }
        }
      }
    }
  });
}

// ========== SECTOR BAR CHART ========== //
const tsContainer = document.getElementById('sector-chart-container');

const tsCanvas = document.createElement('canvas');
tsCanvas.id = 'sectorBarChart';
tsCanvas.classList.add('bar-chart');
tsCanvas.style.marginBottom = '20px';

const tsWrapper = document.createElement('div');
tsWrapper.classList.add('chart-wrapper');
tsWrapper.style.cssText = 'display:flex;gap:24px;align-items:flex-start';
tsWrapper.appendChild(tsCanvas);
tsContainer.appendChild(tsWrapper);

const sectorLabels = sectorBarData.map(i => i.label),
      sectorValues = sectorBarData.map(i => i.value),
      sectorColors = sectorBarData.map(i => i.color);

new Chart(tsCanvas.getContext('2d'), {
  type: 'bar',
  data: {
    labels: sectorLabels,
    datasets: [{
      label: 'Waste by Sector',
      data: sectorValues,
      backgroundColor: sectorColors
    }]
  },
  options: {
    responsive: true,
    indexAxis: 'y',
    plugins: {
      tooltip: {
        callbacks: {
          label: ({ parsed }) => `${parsed.x.toFixed(3)} kg`
        }
      },
      title: { display: false }
    },
    scales: {
      y: { beginAtZero: true, title: { display: true, text: 'Weight (kg)' } },
      x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 20 } }
    }
  }
});

const tsLegendDiv = document.createElement('div');
tsLegendDiv.classList.add('bar-legend');
tsLegendDiv.innerHTML = createLegendHTML(sectorBarData, sectorValues);
const tsLegendWrapper = document.createElement('div');
tsLegendWrapper.appendChild(tsLegendDiv);
tsWrapper.appendChild(tsLegendWrapper);

// ========== SECTOR PIE CHARTS ========== //
const sectorContainer = document.getElementById('sector-pies-container');

for (const [sectorName, pieData] of Object.entries(sectorPieData)) {
  const tabDiv = document.createElement('div');
  tabDiv.id = sectorName.replace(/\s+/g, '');
  tabDiv.classList.add('sector-tabcontent');
  tabDiv.setAttribute('data-section', `top-${sectorName.toLowerCase()}`);

  const headerDiv = document.createElement('div');
  headerDiv.classList.add('sector-header');
  headerDiv.innerHTML = `
    <h2 class="bar-legend-title">${sectorName} Sector</h2>
    <div class="sector-pie-desc" 
         style="background-color: #eef8f2; padding: 1rem; border-radius: 12px; 
                border-left: 6px solid #4CAF50; margin-bottom: 1rem;
                box-sizing: border-box;">
    </div>
  `;

  const flexWrapper = document.createElement('div');
  flexWrapper.classList.add('sector-flex-wrapper');
  flexWrapper.style.cssText = `
    display: flex;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 24px;
    margin: 0 auto;
    width: fit-content;
  `;

  const canvas = document.createElement('canvas');
  canvas.id = `pieChart-${sectorName.replace(/\s+/g, '-')}`;
  canvas.style.cssText = `
    max-width: 425px; 
    max-height: 400px; 
    margin-bottom: 20px;
  `;

  const legendDiv = document.createElement('div');
  legendDiv.classList.add('bar-legend');
  legendDiv.style.cssText = `
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    flex: 1 1 300px;
  `;
  legendDiv.innerHTML = createLegendHTML(
    pieData.labels.map((label, i) => ({
      label,
      value: pieData.data[i],
      color: pieData.backgroundColor[i]
    })), 
    pieData.data
  );

  flexWrapper.append(canvas, legendDiv);
  tabDiv.append(headerDiv, flexWrapper);
  sectorContainer.appendChild(tabDiv);

  new Chart(canvas.getContext('2d'), {
    type: 'pie',
    data: {
      labels: pieData.labels,
      datasets: [{
        data: pieData.data,
        backgroundColor: pieData.backgroundColor,
        hoverOffset: 20
      }]
    },
    options: {
      animation: { duration: 0 },
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            label: ({ raw }) => {
              const total = pieData.data.reduce((a, b) => a + b, 0);
              const pct = total ? ((raw / total) * 100).toFixed(3).replace(/\.0+$/, '') : '0';
              return `${raw.toFixed(3)} kg (${pct}%)`;
            }
          }
        },
        legend: false,
        title: { display: false }
      }
    }
  });
}

insertOverallInsight();
insertPerSupertypeInsights();
insertSectorInsights();
insertSectorOverviewInsight();

</script>

<!-- Trend zoom script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.zoom-range').forEach(slider => {
    const targetId = slider.getAttribute('data-target');
    const container = document.getElementById(targetId);

    if (!container) {
      console.error(`[Zoom] No container for data-target="${targetId}"`);
      return;
    }

    // Set initial base width as visible width
    let baseWidth = container.offsetWidth;

    function applyZoom(v) {
      const percent = Number(v);
      if (!percent || percent <= 0) return;

      // Convert zoom % to pixel width
      const newWidth = Math.max(400, baseWidth * (percent / 100));

      container.style.width = `${newWidth}px`;
      container.style.minWidth = `${newWidth}px`;
    }

    // Initialize
    applyZoom(slider.value);

    slider.addEventListener('input', e => applyZoom(e.target.value));
    window.addEventListener('resize', () => {
      baseWidth = container.offsetWidth;
      applyZoom(slider.value);
    });
  });
});
</script>


<!-- Map view script -->
<script>
  const locations = {{{locations}}};

  if (locations.length === 0) {
    console.warn("No coordinates available for the selected filters.");
  } else {
    const map = L.map('map').setView([locations[0].latitude, locations[0].longitude], 0);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const bounds = [];

    locations.forEach(loc => {
      if (loc.latitude && loc.longitude) {
        const marker = L.marker([loc.latitude, loc.longitude]).addTo(map);
        bounds.push([loc.latitude, loc.longitude]);
      }
    });

    if (bounds.length > 0) {
      map.fitBounds(bounds, {
        padding: [50, 50]
      });
    }
  }
</script>

<!-- JS behind the tabs -->
<script src="/js/tabs.js"></script>
<script src="/js/tabs-bar.js"></script>
<script src="/js/tabs-sector-pie.js"></script>

<style>

.chart-omission-note {
  background: #fff8d8;            /* soft yellow */
  border-left: 4px solid #e0a000; /* warm golden border */
  padding: 0.55rem 0.75rem;
  margin: 0.75rem 0;
  border-radius: 6px;

  font-size: 0.92rem;             /* slightly more readable */
  line-height: 1.35;
  color: #5a4e2e;                 /* muted dark brown for readability */
  display: flex;
  align-items: flex-start;
  gap: 0.45rem;
}

.chart-omission-note i {
  color: #d98200;                 /* darker orange icon */
  margin-top: 1px;                /* slight vertical alignment tweak */
  font-size: 1.05rem;
}

.chart-omission-note b {
  font-weight: 600;
}

.companyLegend {
  margin-top: 10px;
  margin-bottom: 10px;
}

.sim-row {
  display: flex;
  align-items: center;
  gap: 10px;
}
.sim-row label {
  width: 180px;          /* equal label width */
  font-weight: 500;
}
.sim-row input {
  width: 160px !important;          /* equal input width */
}
#runSimBtn {
  width: fit-content;
}

.chart-viewport {
  overflow-x: auto;
  overflow-y: hidden;
  width: 100%;
  border: 2px lightgray solid;
}

.chart-content {
  width: 100%;     /* default baseline */
  min-width: 300px;
}

.zoom-range {
  -webkit-appearance: none;
  width: 220px;
  height: 8px;
  border-radius: 4px;
  background: linear-gradient(90deg, #76c893 0%, #2d613f 100%);
  outline: none;
  cursor: pointer;
  transition: background 0.3s;
}

.zoom-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #fff;
  border: 3px solid #2d613f;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  transition: transform 0.2s, background 0.2s;
}

.zoom-range:hover::-webkit-slider-thumb {
  transform: scale(1.2);
  background: #76c893;
}

.zoom-range::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #fff;
  border: 3px solid #2d613f;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  cursor: pointer;
}

.chart-zoom-slider {
  font-size: 1.1rem;
  color: #2d613f;
  font-weight: bold;
}

.recommendation-box {
  background: #fff;
  border-radius: 8px;
  padding: 0.75rem 1rem;
  margin-top: 0.5rem;
  display: flex;
  align-items: center;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}

.bar-canvas {
  max-width: 700px;
}

[data-section="top-categories"] {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 20px;
  flex-wrap: wrap;
  width: 100%;
  box-sizing: border-box;
}

#summary-legend {
  flex: 1 1 400px;
  min-width: 300px;
  max-width: 600px;
  box-sizing: border-box;
  overflow-wrap: break-word;
}

#summary-legend h2 {
  color: #2d613f;
  margin-bottom: 0.5rem;
}

#summary-legend p {
  font-size: 1rem;
  line-height: 1.4;
}

.click-note {
  color: gray;
  font-style: italic;
  font-size: medium;
}

.participants-list {
  display: none;
}

.participants-list .content {
  max-height: 300px;
  overflow-y: scroll;
  overflow-x: hidden;
  display: flex;
}

.participants-header {
  color: #2d613f;
  font-weight: 600;
  margin-bottom: 1rem;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.toggle-icon {
  transition: transform 0.3s ease;
}

.open .toggle-icon {
  transform: rotate(180deg);
}

.high-priority {
  color: #127009;
  background-color: #c2f3ce;
  padding: 0.75rem;
  border-left: 4px solid #127009;
  border-radius: 6px;
  display: block;
}

.mid-priority {
  color: #cc7a00;
  background-color: #fff4e0;
  padding: 0.75rem;
  border-left: 4px solid #cc7a00;
  border-radius: 6px;
  display: block;
}

.low-priority {
  color: #b30000;
  background-color: #ffe6e6;
  padding: 0.75rem;
  border-left: 4px solid #b30000;
  border-radius: 6px;
  display: block;
}

.insight-general {
  background-color: #eef8f2;
  padding: 1.5rem;
  border-radius: 12px;
  border-left: 6px solid #4CAF50;
  margin-top: 2rem;
}

.insight-compliance {
  background: white;
  border: 1px solid #b5e0b5;
  border-radius: 10px;
  padding: 16px 20px;
  margin: 14px 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  color: #1e4620;
  font-size: 0.95rem;
}
.insight-compliance h3 {
  color: #2e7d32;
  font-size: 1rem;
  margin-bottom: 8px;
}

.compliance-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
  font-size: 0.95rem;
  background-color: #ffffff;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
}

.compliance-table th {
  background-color: #c8e6c9;
  color: #1b5e20;
  text-align: left;
  padding: 10px 12px;
  font-weight: 600;
  border-bottom: 2px solid #a5d6a7;
}

.compliance-table td {
  padding: 9px 12px;
  border-bottom: 1px solid #e0f2e0;
  color: #2e4630;
}

.compliance-table tr:nth-child(even) {
  background-color: #f9fff9;
}

.compliance-table tr:hover {
  background-color: #eef9ee;
  transition: background-color 0.15s ease-in-out;
}

.compliance-table td:nth-child(2),
.compliance-table td:nth-child(3),
.compliance-table td:nth-child(4),
.compliance-table td:nth-child(5) {
  text-align: right;
}

.compliance-table td:nth-child(6) {
  text-align: center;
  font-weight: 600;
}

.non-compliant {
  color: #c62828 !important;
}

.filter-columns {
  display: flex;
  gap: 2rem;
  flex-wrap: wrap;
}

.filter-column {
  flex: 1 1 300px;
  display: flex;
  flex-direction: column;
}

.filter-column label {
  font-weight: 600;
  margin-top: 0.8rem;
  margin-bottom: 0.3rem;
}

.filter-section {
  background: #fafafa;
  border: 1px solid #ccc;
  padding: 1.5rem;
  border-radius: 10px;
  margin-bottom: 1rem;
}

.trend-chart-box {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  margin-bottom: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.trend-chart-box canvas {
  width: 100% !important;
  height: 100% !important;
  max-width: none !important;
}

/* Prevent Chart.js from keeping a minimum width */
.chart-canvas-wrapper,
.trend-chart-box [id$="Container"] {
  min-width: 0 !important;
}

[style*="overflow-x: auto"] {
  min-width: 0 !important;
}

.trend-chart-box h3 {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#trend-charts-wrapper {
  gap: 1.5rem;
}

.trend-chart-box canvas {
  background: linear-gradient(to bottom, #ffffff 0%, #f8fdf8 100%);
  border-radius: 8px;
  padding: 10px;
}

.trend-chart-box {
  position: relative;
  overflow: visible;
}

#trendTotalWasteContainer,
#trendPerCapitaContainer,
#trendByCategoryContainer,
#trendComplianceContainer {
  overflow-x: auto;
  overflow-y: hidden;
  position: relative;
  height: 320px;
  padding-bottom: 10px;
}

#trendTotalWasteContainer::-webkit-scrollbar,
#trendPerCapitaContainer::-webkit-scrollbar,
#trendByCategoryContainer::-webkit-scrollbar,
#trendComplianceContainer::-webkit-scrollbar {
  height: 8px;
}

#trendTotalWasteContainer::-webkit-scrollbar-track,
#trendPerCapitaContainer::-webkit-scrollbar-track,
#trendByCategoryContainer::-webkit-scrollbar-track,
#trendComplianceContainer::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#trendTotalWasteContainer::-webkit-scrollbar-thumb,
#trendPerCapitaContainer::-webkit-scrollbar-thumb,
#trendByCategoryContainer::-webkit-scrollbar-thumb,
#trendComplianceContainer::-webkit-scrollbar-thumb {
  background: #4CAF50;
  border-radius: 4px;
}

#trendTotalWasteContainer::-webkit-scrollbar-thumb:hover,
#trendPerCapitaContainer::-webkit-scrollbar-thumb:hover,
#trendByCategoryContainer::-webkit-scrollbar-thumb:hover,
#trendComplianceContainer::-webkit-scrollbar-thumb:hover {
  background: #388E3C;
}

.info-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  justify-content: center;
}

.info-grid .form-section {
  flex: 1 1 280px;
  min-width: 280px;
}

.user-profile {
  width: 100%;
  border-collapse: collapse;
  margin-top: 0.5rem;
}

.user-profile td {
  padding: 0.5rem 0.75rem;
  border-bottom: 1px solid #eee;
}

.user-profile .label {
  font-weight: 600;
  color: #444;
  width: 50%;
}

.title-card h1 {
  font-size: 1.75rem;
}

.btn-submit {
  background-color: #28a745;
  border: none;
  padding: 0.6rem 1.2rem;
  color: white;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s ease;
}

.btn-submit:hover {
  background-color: #218838;
}

.tab-new {
  text-align: center;
  margin-top: 2rem;
}

.tab-new button {
  background-color: #f1f1f1;
  border: none;
  padding: 0.75rem 1.5rem;
  margin: 0 5px;
  cursor: pointer;
  font-weight: 600;
  border-radius: 8px;
  transition: background-color 0.2s;
}

.tab-new button:hover,
.tab-new button.active {
  background-color: #d0e6ff;
}

.form-section {
  background-color: #fdfdfd;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid #ccc;
  margin: 1.5rem auto;
  font-family: 'Segoe UI', sans-serif;
  color: #333;
}

.form-section h3 {
  font-size: 1.25rem;
  margin-bottom: 1rem;
  color: #2c3e50;
  align-items: center;
}

.form-section h3 i {
  margin-right: 0.6rem;
  color: #127009;
}

.form-section label {
  display: block;
  margin-top: 1rem;
  font-weight: 600;
  font-size: 0.95rem;
}

.form-section input[type="text"],
.form-section input[type="date"],
.form-section input[type="number"],
.form-section select {
  width: 100%;
  padding: 0.5rem;
  margin-top: 0.3rem;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 1rem;
}

.pie-legend {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 12px;
}

.pie-chart {
  flex: 1 1 350px;
  max-width: 500px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.legend-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-radius: 6px;
  color: white;
  font-weight: 500;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  box-sizing: border-box;
}

.legend-name {
  display: flex;
  flex-direction: column;
}

.legend-perc {
  font-size: 0.85rem;
  opacity: 0.9;
}

.legend-kg {
  font-weight: 700;
  font-size: 1.05rem;
}

#togglePieBtn {
  margin-top: 20px;
  padding: 10px 20px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.3s;
}

#togglePieBtn:hover {
  background-color: #45a049;
}

.chart-wrapper {
  display: flex;
  gap: 24px;
  align-items: flex-start;
  margin-bottom: 40px;
}

.bar-legend {
  flex: 1;
  min-width: 250px;
}

.bar-legend-title {
  color: #2d613f;
  margin-bottom: 1rem;
  font-size: 1.2rem;
  text-align: center;
}

.bar-legend-name {
  display: flex;
  flex-direction: column;
}

.bar-legend-perc {
  font-size: 0.85rem;
  opacity: 0.9;
}

.bar-legend-kg {
  font-weight: 700;
  font-size: 1.05rem;
}

.tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #f1f1f1;
  text-align: center;
  border-radius: 8px 8px 0 0;
  margin-top: 20px;
}

.tab button {
  background-color: inherit;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 14px 16px;
  transition: 0.3s;
  font-size: 17px;
  font-weight: 600;
  color: #333;
}

.tab button:hover {
  background-color: #ddd;
}

.tab button.active {
  background-color: #4CAF50;
  color: white;
}

.tabcontent {
  display: none;
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 8px 8px;
  background-color: white;
}

.bar-tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #e8f5e9;
  text-align: center;
  border-radius: 8px 8px 0 0;
  margin-top: 20px;
}

.bar-tab button {
  background-color: inherit;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 12px 14px;
  transition: 0.3s;
  font-size: 15px;
  font-weight: 600;
  color: #2d613f;
}

.bar-tab button:hover {
  background-color: #c8e6c9;
}

.bar-tab button.active {
  background-color: #4CAF50;
  color: white;
}

.bar-tabcontent {
  display: none;
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 8px 8px;
  background-color: white;
}

.sector-tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #e3f2fd;
  text-align: center;
  border-radius: 8px 8px 0 0;
  margin-top: 20px;
}

.sector-tab button {
  background-color: inherit;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 12px 14px;
  transition: 0.3s;
  font-size: 15px;
  font-weight: 600;
  color: #1565C0;
}

.sector-tab button:hover {
  background-color: #bbdefb;
}

.sector-tab button.active {
  background-color: #2196F3;
  color: white;
}

.sector-tabcontent {
  display: none;
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 8px 8px;
  background-color: white;
}

#map {
  height: 400px;
  border-radius: 8px;
  border: 2px solid #ccc;
}

@media print {
  .modal {
    display: none !important;
  }
  
  .btn-customize {
    display: none !important;
  }
  
  body {
    background: white;
  }
  
  .form-section {
    page-break-inside: avoid;
  }
}

.simulation-container {
  background-color: #fdfdfd;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid #ccc;
  margin: 2rem auto;
  max-width: 950px;
  color: #333;
  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
}

.model-controls {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

button {
  background-color: #28a745;
  border: none;
  color: #fff;
  padding: 0.6rem 1.2rem;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
}

button:hover {
  background-color: #23963b;
}

.summary-box {
  margin-top: 1rem;
  padding: 1rem;
  border: 1px solid #ccc;
  border-radius: 10px;
  background-color: #f9fff9;
  font-family: 'Segoe UI', sans-serif;
}

#simulationChart {
  background: #f8fdf8;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  padding: 10px;
}

</style>