<!-- Display search parameters if current route has query -->    
<div id="filter-section" class="filter-section" data-section="filters">
    <center>
        <h2 style="margin: 0;">Search Parameters</h2>
    </center>
    <div class="filter-columns">

        <!-- Location Filters -->
        <div class="filter-column">
            <label for="region">Region</label>
            {{regionName}}

            <label for="province">Province</label>
            {{provinceName}}

            <label for="municipality">City/Municipality</label>
            {{municipalityName}}

            <label for="barangay">Barangay</label>
            {{barangayName}}
        </div>

        <!-- Author & Date Filters -->
        <div class="filter-column">
            <label>Title</label>
            {{query.title}} {{#ifEquals query.title undefined}}ALL{{/ifEquals}}

            <label for="filter-author">Author</label>
            {{query.author}} {{#ifEquals query.author undefined}}ALL{{/ifEquals}}

            <label for="filter-org">Organization Name</label>
            {{query.company}} {{#ifEquals query.company undefined}}ALL{{/ifEquals}}

            <label>Collection Date Range</label>
            <div class="date-range">
                {{query.startDate}} {{#ifEquals query.startDate undefined}}--{{/ifEquals}} to
                {{query.endDate}} {{#ifEquals query.endDate undefined}}--{{/ifEquals}}
            </div>
        </div>

        <!-- Additional Metrics Filters -->
        <div class="filter-column">
            <label>Time Aggregation</label>
            {{#if query.aggregation}}
                {{#ifEquals query.aggregation "monthly"}}Monthly{{/ifEquals}}
                {{#ifEquals query.aggregation "yearly"}}Yearly{{/ifEquals}}
            {{else}}
                Not Set
            {{/if}}
        </div>
    </div>
</div>

<!-- Display charts for aggregated data -->
<!-- Title Card -->
<div class="form-section title-card" style="text-align: center;" data-section="data-title">
    <h1 style="margin-bottom: 0.25rem;">
      GreenCycle Dashboard ‚Äì Data Summary
    </h1>
    <p style="font-size: large;">
        {{#if query.aggregation}}
            {{#ifEquals query.aggregation "monthly"}}Monthly{{/ifEquals}}
            {{#ifEquals query.aggregation "yearly"}}Yearly{{/ifEquals}}
            aggregated data for the requested entries.
        {{else}}
            Overall summary data for the requested entries.
        {{/if}}
    </p>
</div>

<!-- Participants Section -->
<div class="form-section closed" 
     style="background-color: #f0fff4; padding: 1.5rem; border-radius: 12px; margin: 0.5rem 0;">
  
  <h2 class="participants-header" onclick="toggleCategory(this)">
    <span>
      <i class="fa-solid fa-users" style="margin-right: 10px; color: #4CAF50;"></i>
      Participants Included

      <br><span class="click-note">(Click to show list of participants)</span>
    </span>
    <i class="fas fa-chevron-down toggle-icon"></i>
  </h2>

  <div class="form-section participants-list" data-section="participants">
    <div class="content">
      <!-- Orgs and Users List -->
      <div style="margin-bottom: 1rem; width: 50%">
        <strong style="color:#2d613f;">Organizations & Users:</strong>
        {{#if orgGroups.length}}
          <ul style="padding-left: 1.5rem;">
            {{#each orgGroups}}
              <li>
                <strong>{{company_name}}</strong>
                <ul style="list-style-type: circle; padding-left: 1.5rem; margin: 0.25rem 0;">
                  {{#each users}}
                    <li>{{this}}</li>
                  {{/each}}
                </ul>
              </li>
            {{/each}}
          </ul>
        {{else}}
          <p style="margin: 0.5rem 0; color: #777;">None</p>
        {{/if}}
      </div>

      <!-- Locations -->
      <div style="width: 50%">
        <strong style="color:#2d613f;">Locations:</strong>
        {{#if uniqueLocations.length}}
          <ul style="list-style-type: disc; padding-left: 1.5rem; margin: 0.5rem 0;">
            {{#each uniqueLocations}}
              <li style="margin-bottom: 0.25rem; color: #333;">{{this}}</li>
            {{/each}}
          </ul>
        {{else}}
          <p style="margin: 0.5rem 0; color: #777;">None</p>
        {{/if}}
      </div>
    </div>
  </div>
</div>


<!-- Initial Summary -->
<div style="display: flex;">
  <div data-section="data-info">
    <!-- Waste Generation Info -->
    <div class="form-section">
        <h3><i class="fas fa-dumpster"></i> Waste Generation</h3>
        <table class="user-profile">
        <tr>
            <td class="label">Average Waste Generation per Capita (Kg/cap-day)</td>
            <td>{{commaNumber avgInfo.avg_per_capita}}</td>
        </tr>
        <tr>
            <td class="label">Average Annual Waste Generation (kg/year)</td>
            <td>{{commaNumber avgInfo.avg_annual}}</td>
        </tr>
        </table>
    </div>

    <!-- Collection Info -->
    <div class="form-section">
        <h3><i class="fas fa-calendar-alt"></i> Overall Collection Period</h3>
        <table class="user-profile">
        <tr>
            <td class="label">Earliest Start Date</td>
            <td>{{textDate avgInfo.earliest_collection_start}}</td>
        </tr>
        <tr>
            <td class="label">Latest End Date</td>
            <td>{{textDate avgInfo.latest_collection_end}}</td>
        </tr>
        </table>
    </div>
  </div>

  <!-- Map view -->
  <div id="map" style="margin-bottom: 10px; flex: 1;" data-section="map"></div>
</div>

<!-- NEW: Trends Over Time Section -->
<div class="form-section" style="background-color: #f8f9ff; padding: 2rem; border-radius: 12px; border-left: 6px solid #2196F3;" data-section="trends">
  <h2 id="trends-main-title" style="color: #1565C0; font-weight: 600; margin-bottom: 1rem; display: flex">
    <i class="fa-solid fa-chart-line" style="margin-right: 10px; color: #2196F3;"></i>
    Trends Over Time

    <span id="aggregation-view-label" style="font-size: 0.9rem; color: #666; font-weight: 400; margin-left: 10px;">
      ({{#ifEquals query.aggregation "monthly"}}Monthly{{/ifEquals}}{{#ifEquals query.aggregation "yearly"}}Yearly{{/ifEquals}} Averaging Aggregation)
    </span>

    <!-- Aggregation settings -->
    <select id="select-aggregation" style="margin-left: auto; width: 200px;">
      <option value="monthly" {{#ifEquals query.aggregation "monthly"}}selected{{/ifEquals}}>Monthly Summary</option>
      <option value="yearly" {{#ifEquals query.aggregation "yearly"}}selected{{/ifEquals}}>Yearly Summary</option>
    </select>&nbsp;

    <button class="btn-primary" id="applyBtn">
      <i class="fa-solid fa-check"></i> Apply Filters
    </button>
  </h2>
  
  <p style="color: #555; margin-bottom: 1.5rem;">
    Visualize waste generation patterns over time using averaging aggregation:<br>
    <h2>
      <math style="background-color:#fff;padding:10px;border-radius:5px;">
        <mrow>
          <mi>y</mi><mi>(</mi><mi>fc</mi><mi>)</mi>
          <mo>=</mo>
          <mfrac>
            <mn>1</mn>
            <mrow>
              <msub><mi>T</mi><mn>2</mn></msub>
              <mo>-</mo>
              <msub><mi>T</mi><mn>1</mn></msub>
            </mrow>
          </mfrac>
          <mo>√ó</mo>
          <mi>Œ£y(i)</mi>
        </mrow>
      </math>
    </h2>
    Use the aggregation selector to switch between monthly or yearly views. You may drag the horizontal scrollbar on each chart to view further time periods.
  </p>

  <!-- Company color legend -->
  <div style="
      background-color: #fff;
      padding: 10px;
      margin-top: 10px;
      margin-bottom: 10px;
      border-radius: 5px;">
    <center>
      <h2 style="margin: 0;">COMPANY LEGEND</h2>
      <p>GreenCycle uses data provided by different organizations. Below is a color legend for the organizations used in this data summary.</p>
    </center>
    <div class="companyLegend"></div>
  </div>

  <!-- Trend Charts Container -->
  <div id="trend-charts-wrapper">
    <!-- Total Waste Trend with Regression -->
    <div class="trend-chart-box" data-section="trends-wastegen">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-trash"></i> Total Waste Generation Trend with 3rd Degree Polynomial Regression
      </h3>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider" style="margin-bottom: 0.75rem;">
        <label style="font-size: 0.85rem; margin-right: 0.5rem; color: #2d613f;">
          Zoom Width:
        </label>
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendTotalWasteContainer"
          min="40" 
          max="200" 
          value="50" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>

      <div class="chart-viewport">
        <div id="trendTotalWasteContainer" class="chart-content">
          <canvas id="trendTotalWaste"></canvas>
        </div>
      </div>
      <div style="margin-top: 1rem; padding: 1rem; background: #e8f5e9; border-radius: 6px; font-size: 0.9rem;">
        <strong style="color: #2d613f;">üìä Trend Analysis:</strong>
        <span id="regressionStats" style="color: #555;"></span>
      </div>
    </div>

    <!-- Per Capita Trend -->
    <div class="trend-chart-box" data-section="trends-percapita">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-user"></i> Per Capita Waste Trend
      </h3>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider" style="margin-bottom: 0.75rem;">
        <label style="font-size: 0.85rem; margin-right: 0.5rem; color: #2d613f;">
          Zoom Width:
        </label>
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendPerCapitaContainer"
          min="40" 
          max="200" 
          value="50" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>

      <div class="chart-viewport">
        <div id="trendPerCapitaContainer" class="chart-content">
          <canvas id="trendPerCapita"></canvas>
        </div>
      </div>
    </div>

    <!-- Waste by Category Trend -->
    <div class="trend-chart-box" data-section="trends-category">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-layer-group"></i> Waste by Category Over Time
      </h3>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider" style="margin-bottom: 0.75rem;">
        <label style="font-size: 0.85rem; margin-right: 0.5rem; color: #2d613f;">
          Zoom Width:
        </label>
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendByCategoryContainer"
          min="40" 
          max="200" 
          value="50" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>

      <div class="chart-viewport">
        <div id="trendByCategoryContainer" class="chart-content">
          <canvas id="trendByCategory"></canvas>
        </div>
      </div>
    </div>

    <!-- Compliance Trend -->
    <div class="trend-chart-box" data-section="trends-compliance">
      <h3 style="color: #2d613f; font-size: 1.1rem; margin-bottom: 0.75rem;">
        <i class="fa-solid fa-check-double"></i> Compliance Rate Trend
      </h3>

      <div class="companyLegend"></div>

      <!-- Zoom -->
      <div class="chart-zoom-slider" style="margin-bottom: 0.75rem;">
        <label style="font-size: 0.85rem; margin-right: 0.5rem; color: #2d613f;">
          Zoom Width:
        </label>
        <input 
          type="range" 
          class="zoom-range" 
          data-target="trendComplianceContainer"
          min="40" 
          max="200" 
          value="50" 
          step="5"
          style="width: 220px; cursor: pointer;"
        >
      </div>

      <div class="chart-viewport">
        <div id="trendComplianceContainer" class="chart-content">
          <canvas id="trendCompliance"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Simulation UI (updated) -->
<div class="form-section" style="background-color:#f4fff6;padding:1.5rem;border-radius:10px;border-left:6px solid #43a047;">
  <h2 style="color:#2e7d32;display:flex;align-items:center;">
    <i class="fa-solid fa-flask" style="margin-right:8px;color:#43a047"></i>
    Waste Simulation Forecast
  </h2>

  <p style="color:#555;margin-bottom:1rem;">
    Uses historical <strong>data_entry.annual</strong> values. Population input is a whole
    percentage (e.g. <b>1</b> = 1%). Linear yearly auto-increment is fixed at <b>5% per year</b>.
  </p>

  <div style="background:#e8f5e9;padding:14px;border-radius:10px;display:flex;flex-direction:column;gap:12px;">

    <div class="sim-row">
      <label for="forecastMonths" style="font-weight:600;">Forecast Horizon (months)</label>
      <input id="forecastMonths" type="number" class="form-control" value="12" min="1" max="240">
    </div>

    <div class="sim-row">
      <label style="font-weight:600;">Additional Companies (can be negative)</label>
      <div style="display:flex;gap:12px;margin-top:6px;">
        <div style="flex:1;">
          <label for="addSmall" style="font-size:0.9rem;">Small</label>
          <input id="addSmall" type="number" class="form-control" value="0" step="1">
        </div>
        <div style="flex:1;">
          <label for="addMedium" style="font-size:0.9rem;">Medium</label>
          <input id="addMedium" type="number" class="form-control" value="0" step="1">
        </div>
        <div style="flex:1;">
          <label for="addLarge" style="font-size:0.9rem;">Large</label>
          <input id="addLarge" type="number" class="form-control" value="0" step="1">
        </div>
      </div>
     <small style="color:#555;">
        Enter negative numbers to indicate companies that left the system or are no longer part of the simulation (e.g. -1).
     </small>
    </div>

    <div class="sim-row">
      <label for="populationInputWhole" style="font-weight:600;">Population (whole percent)</label>
      <input id="populationInputWhole" type="number" class="form-control" value="0" step="1" placeholder="e.g. 1 = 1%">
      <small style="color:#555;">This whole-number percent is converted to a decimal and <b>added</b> to the scale (not multiplied).</small>
    </div>

    <button id="runSimBtn" class="btn btn-success" style="margin-top:6px;">
      <i class="fa-solid fa-play"></i> Run Simulation
    </button>
  </div>

  <div style="margin-top:12px;background:#fff;padding:12px;border-radius:8px;">
    <canvas id="simulationChart" height="340"></canvas>
  </div>

  <div style="margin-top:12px;">
    <h3 id="simHeader"></h3>
    <table style="width:100%;border:1px solid #eee;border-radius:6px;">
      <tbody id="simDiagnostics" style="font-size:0.95rem;"></tbody>
    </table>
  </div>
</div>


<!-- Compliance Overview -->
<div class="form-section" style="background-color: rgb(240, 255, 240); padding: 10px 15px; border-left: 4px solid #4caf50; margin-bottom: 15px;">
  <h2>About Diversion Rates and Compliance</h2>
  <p>
    <b>Diversion</b> refers to the portion of waste that is prevented from going to landfills or open dumps, whether before or after collection. This includes waste sent to <b>processing or recovery facilities</b> such as Materials Recovery Facilities (MRFs) where it can be reused, recycled, or converted for other uses.
  </p>
  <p>
    Tracking and meeting <b>diversion targets</b> is essential for reducing landfill dependence, minimizing environmental pollution, and supporting sustainable waste management systems. Regular compliance tracking helps local governments and sectors assess their performance and optimize recovery operations.
  </p>
</div>

<div style="display: flex; gap: 10px; flex-wrap: wrap;">
    <!-- Compliance -->
    <div class="form-section" style="background-color: rgb(227, 255, 227); flex: 1 1 calc(50% - 5px);" data-section="compliance-category">
      <h2>Waste Category Compliance Status</h2>

      <!-- Insights -->
      {{{wasteComplianceNarrative}}}

      <table class="compliance-table">
        <tr>
          <th>Waste Category</th>
          <th>Collected</th>
          <th>Total Generated</th>
          <th>Diversion %</th>
          <th>Target %</th>
          <th>Status</th>
        </tr>
        {{#each wasteCompliances}}
          <tr>
            <td>{{supertype_name}}</td>
            <td>{{formatNumber total_collected_weight}} kg</td>
            <td>{{formatNumber total_generated}} kg</td>
            <td>{{diversion_percentage}}%</td>
            <td>{{target_percentage}}%</td>
            <td class="{{#if (eq compliance_status 'Non-Compliant')}}non-compliant{{/if}}">{{compliance_status}}</td>
          </tr>
        {{/each}}
      </table>
    </div>

    <div class="form-section" style="background-color: rgb(227, 255, 227); flex: 1 1 calc(50% - 5px);" data-section="compliance-sector">
      <h2>Waste Sector Compliance Status</h2>
      
      <!-- Insights -->
      {{{sectorComplianceNarrative}}}

      <table class="compliance-table">
        <tr>
          <th>Sector Category</th>
          <th>Collected</th>
          <th>Total Generated</th>
          <th>Diversion %</th>
          <th>Target %</th>
          <th>Status</th>
        </tr>
        {{#each sectorCompliances}}
          <tr>
            <td>{{sector_name}}</td>
            <td>{{formatNumber total_collected_weight}} kg</td>
            <td>{{formatNumber total_generated}} kg</td>
            <td>{{diversion_percentage}}%</td>
            <td>{{target_percentage}}%</td>
            <td class="{{#if (eq compliance_status 'Non-Compliant')}}non-compliant{{/if}}">{{compliance_status}}</td>
          </tr>
        {{/each}}
      </table>
    </div>
  </div>

<!-- Insight -->
<hr>
<div data-section="insights" class="form-section" style="background-color: #eef8f2; padding: 1.5rem; border-radius: 12px; border-left: 6px solid #4CAF50; margin-top: 2rem;">
  <h2 style="color: #2d613f;"><i class="fa-solid fa-lightbulb" style="margin-right: 8px;"></i>General Waste Category Insights & Recommendations</h2>
  <ul style="font-size: 1.1rem; list-style-type: none; padding-left: 0;">
    {{#each recommendations}}
      <li style="margin-bottom: 1rem;">{{{this}}}</li>
    {{/each}}
  </ul>
</div>

<!-- Data Tabs -->
<div class="tab">
  <button class="tablinks" onclick="openTab(event, 'Chart')" id="defaultOpen">CHART</button>
</div>

<!-- Display A: Chart -->
<div id="Chart" class="tabcontent">
    <!-- Supertype summary pie chart -->
    <div data-section="top-categories">
      <div style="text-align: center;">
        <h2>Top Waste Categories in This Area</h2>
        <p style="font-size: large;" id="summary-description">This pie chart shows the distribution of waste by supertype. Each slice represents the total weight (in kilograms) of waste classified as Biodegradable, Recyclable, Residual, or Special/Hazardous. Hover over a slice to view its percentage and absolute weight.</p>
      </div>

      <div style="display: flex;">
        <div class="pie-chart">
            <canvas id="supertypePieChart">
                <!-- Populated by JS -->
            </canvas>
        </div>

        <div id="summary-legend">
          <div id="summary-insight"></div>
            {{#each legendData}}
                {{#if (gt value 0)}}
                <span class="legend-item" style="background-color: {{color}}">
                    <span class="legend-name">
                        {{label}}
                        <span class="legend-perc">{{calcPercent value ../legendData}}%</span>
                    </span>
                    <span class="legend-kg">
                        {{toFixed value 3}} kg
                    </span>
                </span>
                {{/if}}
            {{/each}}

            <!-- Toggle showing summary or detailed pie -->
            <button id="togglePieBtn" class="no-print"><i class="fa-solid fa-circle-info"></i>&nbsp; Show Detailed Pie Chart</button>
        </div>
      </div>
    </div><br>

    <!-- Subtypes bar charts -->
    <hr>
    <br><center data-section="top-cats">
        <h2>Top Waste Types by Category</h2>
        <p style="font-size: large;">Each bar chart below focuses on one waste category. The bars represent different types under that category, showing how much each contributed to the total weight.</p>
    </center>
    <div class="bar-tab">
        <button class="bar-tablinks" onclick="openBarTab(event, 'Biodegradable')" id="firstBar">BIODEGRADABLE</button>
        <button class="bar-tablinks" onclick="openBarTab(event, 'Recyclable')">RECYCLABLE</button>
        <button class="bar-tablinks" onclick="openBarTab(event, 'Residual')">RESIDUAL</button>
        <button class="bar-tablinks" onclick="openBarTab(event, 'Special/Hazardous')">SPECIAL/HAZARDOUS</button>
    </div>

    <div id="bar-charts-container"></div>

    <!-- Top sectors producing waste -->
    <br><hr><br>
    <div data-section="top-sectors">
      <center>
        <h2>Top Sectors by Waste Output</h2>
        <p style="font-size: large;">This chart shows which economic sectors contribute the most to total waste generation. Use this insight to target waste reduction initiatives by sector.</p>
      </center>
      <div id="sector-insight"></div>
      <div id="sector-chart-container"></div>
    </div>

    <!-- Pie chart per sector -->
    <br><hr><br>
    <center data-section="cats-per-sector">
      <h2>Top Waste Categories per Sector</h2>
      <p style="font-size: large;">Each pie chart below shows the waste composition for a specific economic sector.</p>
    </center>

    <div class="sector-tab">
        <button class="sector-tablinks" onclick="openPieTab(event, 'Residential')" id="firstSector">RESIDENTIAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Commercial')">COMMERCIAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Institutional')">INSTITUTIONAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Industrial')">INDUSTRIAL</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'Health')">HEALTH</button>
        <button class="sector-tablinks" onclick="openPieTab(event, 'AgricultureandLivestock')">AGRICULTURE AND LIVESTOCK</button>
    </div>

    <div id="sector-pies-container"></div>
</div>

<!-- Access to chart.js - MUST BE LOADED BEFORE CHART SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>

<!-- Leaflet.js (for map view) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- Participants toggle -->
<script>
function toggleCategory(header) {
    const category = header.parentElement;
    category.classList.toggle('open');

    const content = category.querySelector('.participants-list');
    content.style.display = content.style.display === 'block' ? 'none' : 'block';
}
</script>

<!-- Aggregation Selection Script -->
<script>

window.currentFilters = {{{json query}}};

const applyBtn = document.getElementById('applyBtn');

applyBtn.onclick = async () => {
    const aggregation = document.getElementById('select-aggregation').value;

    // Section toggle logic stays the same
    const selectedSections = Array.from(document.querySelectorAll('input[name="section"]:checked'))
        .map(cb => cb.value);

    document.querySelectorAll('[data-section]').forEach(el => {
        if (el.getAttribute('data-section') !== 'filters' && el.getAttribute('data-section') !== 'data-title') {
            el.style.display = 'none';
        }
    });

    selectedSections.forEach(section => {
        document.querySelectorAll(`[data-section="${section}"]`).forEach(el => el.style.display = '');
    });

    // Build query params from current filters
    const url = new URL('/dashboard/data/summary/timeseries', window.location.origin);
    const params = new URLSearchParams(window.location.search);

    params.set('aggregation', aggregation);
    url.search = params.toString();

    // Fetch updated time-series without reloading page
    const response = await fetch(url.toString());
    const data = await response.json();

    // Update chart (example)
    updateTimeSeriesChart(data.timeSeriesData);

    // Optional: update query param in URL without reload
    const newPageUrl = new URL(window.location.href);
    newPageUrl.searchParams.set('aggregation', aggregation);
    window.history.replaceState({}, '', newPageUrl.toString());
};

</script>

<!-- Simulation script -->
<script>
async function runSimulation() {
  const btn = document.getElementById('runSimBtn');
  const horizon = Number(document.getElementById('forecastMonths').value) || 12;

  const additions = {
    small: Number(document.getElementById('addSmall').value) || 0,
    medium: Number(document.getElementById('addMedium').value) || 0,
    large: Number(document.getElementById('addLarge').value) || 0
  };

  // population as WHOLE number: 1 = 1%
  const populationInputWhole = Number(document.getElementById('populationInputWhole').value) || 0;

  const filters = window.currentFilters || {};

  const payload = { horizon, filters, additions, populationInputWhole };
  console.log('[UI] payload', payload);

  btn.disabled = true;
  btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Running...';

  try {
    const res = await fetch('/api/simulate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const json = await res.json();
    console.log('[UI] Simulation Response:', json);

    if (!json.success || !json.forecast || json.forecast.length === 0) {
      alert('No forecast returned. Ensure filtered entries include annual values.');
      if (json.diagnostics) renderDiagnostics(json.diagnostics);
      return;
    }

    renderSimulationChart(json.forecast);
    renderDiagnostics(json.diagnostics);
  } catch (err) {
    console.error('[UI] Simulation fetch error:', err && err.stack ? err.stack : err);
    alert('Simulation fetch error ‚Äî check console.');
  } finally {
    btn.disabled = false;
    btn.innerHTML = '<i class="fa-solid fa-play"></i> Run Simulation';
  }
}

function renderSimulationChart(forecast) {
  const canvas = document.getElementById('simulationChart');
  if (!canvas) { console.error('Chart canvas not found'); return; }
  const ctx = canvas.getContext('2d');
  if (!ctx) { console.error('getContext() returned null'); return; }

  if (window.simChart && typeof window.simChart.destroy === 'function') window.simChart.destroy();

  const labels = forecast.map(f => f.period);
  const data = forecast.map(f => Number(f.mean));

  window.simChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: 'Simulated Monthly Waste (kg)',
        data,
        borderColor: 'rgb(75,192,192)',
        borderWidth: 2.5,
        tension: 0.25,
        fill: false
      }]
    },
    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom' } } }
  });
}

function renderDiagnostics(d) {
  document.getElementById('simHeader').innerText = 'Simulation Diagnostics';

  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const template = Array.isArray(d.monthTemplatePerCompany) ? d.monthTemplatePerCompany : [];
  const templateStr = template.length === 12 ? template.map((v,i) => `${monthNames[i]}: ${v.toFixed(2)}`).join(', ') : '-';

  document.getElementById('simDiagnostics').innerHTML = `
    <tr><th>Forecast Horizon</th><td>${d.horizon ?? '-' } months</td></tr>
    <tr><th>Anchor Month</th><td>${d.anchorMonth ?? '-'}</td></tr>
    <tr><th>Distinct Companies</th><td>${d.distinctCompanies ?? '-'}</td></tr>
    <tr><th>Actual Company Equivalent</th><td>${d.actualCompanyEquivalent ?? '-'}</td></tr>
    <tr><th>Additions (S/M/L)</th><td>${d.additions ? `${d.additions.small}/${d.additions.medium}/${d.additions.large}` : '-'}</td></tr>
    <tr><th>Added Equivalent</th><td>${d.addEquivalent ?? '-'}</td></tr>
    <tr><th>Company Base</th><td>${d.companyBase ?? '-'}</td></tr>
    <tr><th>Population Input (whole %)</th><td>${d.populationInputWhole ?? '-'}</td></tr>
    <tr><th>Population Offset Applied</th><td>${d.populationOffsetApplied ?? '-'}</td></tr>
    <tr><th>Scale Base</th><td>${d.scaleBase ?? '-'}</td></tr>
    <tr><th>Yearly Increment Rate</th><td>5% (auto)</td></tr>
    <tr><th>Monthly Template (per company)</th><td style="white-space:normal;">${templateStr}</td></tr>
    <tr><th>Companies Involved</th><td>${(d.companiesInvolved || []).join(', ')}</td></tr>
    <tr><th>Note</th><td>${d.note ?? '-'}</td></tr>
  `;
}

document.getElementById('runSimBtn').addEventListener('click', runSimulation);
</script>

<!-- CORRECTED - Retrieves Individual Category/Sector Compliance Status -->
<script>

// ============================================================================
// TREND CHARTS - PROPER COMPLIANCE RETRIEVAL PER ENTRY
// ============================================================================

function parseFlexibleDate(input) {
  if (!input) return null;
  const str = String(input).trim();
  
  if (input instanceof Date) return input;
  
  if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
    return new Date(str);
  }
  
  if (/^\d{8}$/.test(str)) {
    const year = parseInt(str.slice(0, 4), 10);
    const month = parseInt(str.slice(4, 6), 10) - 1;
    const day = parseInt(str.slice(6, 8), 10);
    return new Date(year, month, day);
  }
  
  if (/^\d{6}$/.test(str)) {
    const year = parseInt(str.slice(0, 4), 10);
    const month = parseInt(str.slice(4, 6), 10) - 1;
    return new Date(year, month, 1);
  }
  
  const parsed = new Date(str);
  return isNaN(parsed) ? null : parsed;
}

function getTimeSpanInDays(startDate, endDate) {
  const msPerDay = 24 * 60 * 60 * 1000;
  return Math.round((endDate - startDate) / msPerDay) + 1;
}

// Expected category and sector names
const CATEGORY_NAMES = ['Biodegradable', 'Recyclable', 'Residual', 'Special/Hazardous'];
const SECTOR_NAMES = ['Residential', 'Commercial', 'Institutional', 'Industrial', 'Health', 'Agriculture and Livestock'];

function aggregateDataWithAveraging(dataPoints, aggregationType) {
  const aggregated = {};
  
  dataPoints.forEach(point => {
    const date = parseFlexibleDate(point.date);
    if (!date || isNaN(date)) return;
    
    let key, periodStart, periodEnd;
    
    if (aggregationType === 'monthly') {
      key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      periodStart = new Date(date.getFullYear(), date.getMonth(), 1);
      periodEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
    } else if (aggregationType === 'yearly') {
      key = `${date.getFullYear()}`;
      periodStart = new Date(date.getFullYear(), 0, 1);
      periodEnd = new Date(date.getFullYear(), 11, 31);
    }
    
    if (!aggregated[key]) {
      aggregated[key] = {
        totalWeight: 0,
        perCapita: 0,
        periodStart: periodStart,
        periodEnd: periodEnd,
        wasteByCategory: {},
        wasteBySector: {},
        // Track compliance per entry
        totalComplianceItems: 0,
        compliantItems: 0
      };
    }
    
    aggregated[key].totalWeight += parseFloat(point.total_weight) || 0;
    aggregated[key].perCapita += parseFloat(point.avg_per_capita) || 0;
    
    const category = point.waste_type || 'Unknown';
    if (!aggregated[key].wasteByCategory[category]) {
      aggregated[key].wasteByCategory[category] = 0;
    }
    aggregated[key].wasteByCategory[category] += parseFloat(point.total_weight) || 0;
    
    // ========== NEW: CHECK INDIVIDUAL COMPLIANCE FOR EACH ENTRY ==========
    
    // Check 4 categories
    CATEGORY_NAMES.forEach(catName => {
      // Try different possible field names for category compliance
      const catKey = catName.replace(/[\/\s]/g, '_').toLowerCase();
      const complianceField = 
        point[`${catKey}_compliance`] || 
        point[`${catKey}_status`] ||
        point[`compliance_${catKey}`] ||
        point[`status_${catKey}`];
      
      aggregated[key].totalComplianceItems += 1;
      
      if (complianceField === 'Compliant' || complianceField === 'compliant') {
        aggregated[key].compliantItems += 1;
      }
      
      // Log for debugging (first entry only)
      if (aggregated[key].totalComplianceItems === 1) {
        console.log(`üîç Checking category "${catName}":`, complianceField);
      }
    });
    
    // Check 6 sectors
    SECTOR_NAMES.forEach(secName => {
      // Try different possible field names for sector compliance
      const secKey = secName.replace(/[\/\s]/g, '_').toLowerCase();
      const complianceField = 
        point[`${secKey}_compliance`] || 
        point[`${secKey}_status`] ||
        point[`compliance_${secKey}`] ||
        point[`status_${secKey}`] ||
        point[`sector_${secKey}_compliance`] ||
        point[`sector_${secKey}_status`];
      
      aggregated[key].totalComplianceItems += 1;
      
      if (complianceField === 'Compliant' || complianceField === 'compliant') {
        aggregated[key].compliantItems += 1;
      }
      
      // Log for debugging (first entry only)
      if (aggregated[key].totalComplianceItems === 5) {
        console.log(`üîç Checking sector "${secName}":`, complianceField);
      }
    });
    
    // Alternative: If compliance data is stored in nested objects
    if (point.category_compliance) {
      CATEGORY_NAMES.forEach(catName => {
        const status = point.category_compliance[catName];
        if (status === 'Compliant' || status === 'compliant') {
          // Already counted above, just for reference
        }
      });
    }
    
    if (point.sector_compliance) {
      SECTOR_NAMES.forEach(secName => {
        const status = point.sector_compliance[secName];
        if (status === 'Compliant' || status === 'compliant') {
          // Already counted above, just for reference
        }
      });
    }
  });
  
  Object.keys(aggregated).forEach(key => {
    const data = aggregated[key];
    const timeSpan = getTimeSpanInDays(data.periodStart, data.periodEnd);
    
    data.avgTotalWeight = data.totalWeight / timeSpan;
    data.avgPerCapita = data.perCapita / timeSpan;
    data.timeSpan = timeSpan;
    
    // Calculate compliance rate
    data.complianceRate = data.totalComplianceItems > 0 
      ? (data.compliantItems / data.totalComplianceItems) * 100 
      : 0;
    
    const numEntries = data.totalComplianceItems / 10;
    console.log(`üìä ${key}: ${data.compliantItems}/${data.totalComplianceItems} compliant = ${data.complianceRate.toFixed(1)}% (${numEntries} entries)`);
  });
  
  return aggregated;
}

function generateFutureLabels(lastPeriod, aggregationType, numPeriods = 3) {
  const labels = [];
  
  if (aggregationType === 'monthly') {
    const [year, month] = lastPeriod.split('-').map(Number);
    let currentYear = year;
    let currentMonth = month;
    
    for (let i = 1; i <= numPeriods; i++) {
      currentMonth += 1;
      if (currentMonth > 12) {
        currentMonth = 1;
        currentYear += 1;
      }
      labels.push(`${currentYear}-${String(currentMonth).padStart(2, '0')}`);
    }
  } else if (aggregationType === 'yearly') {
    const year = parseInt(lastPeriod);
    for (let i = 1; i <= numPeriods; i++) {
      labels.push(`${year + i}`);
    }
  }
  
  return labels;
}

function formatPeriodLabel(period, aggregationType) {
  if (aggregationType === 'monthly') {
    const [year, month] = period.split('-');
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return `${monthNames[parseInt(month) - 1]} ${year}`;
  } else if (aggregationType === 'yearly') {
    return period;
  }
  return period;
}

function calculatePolynomialRegression(xValues, yValues, degree = 3) {
  const n = xValues.length;
  const actualDegree = Math.min(degree, n - 1);
  
  const matrix = [];
  const vector = [];
  
  for (let i = 0; i <= actualDegree; i++) {
    const row = [];
    for (let j = 0; j <= actualDegree; j++) {
      let sum = 0;
      for (let k = 0; k < n; k++) {
        sum += Math.pow(xValues[k], i + j);
      }
      row.push(sum);
    }
    matrix.push(row);
    
    let sum = 0;
    for (let k = 0; k < n; k++) {
      sum += yValues[k] * Math.pow(xValues[k], i);
    }
    vector.push(sum);
  }
  
  const coefficients = gaussianElimination(matrix, vector);
  
  const yMean = yValues.reduce((a, b) => a + b, 0) / n;
  const ssTotal = yValues.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
  const ssResidual = yValues.reduce((sum, y, i) => {
    const predicted = evaluatePolynomial(coefficients, xValues[i]);
    return sum + Math.pow(y - predicted, 2);
  }, 0);
  const rSquared = 1 - (ssResidual / ssTotal);
  
  return { coefficients, rSquared, degree: actualDegree };
}

function gaussianElimination(matrix, vector) {
  const n = matrix.length;
  const augmented = matrix.map((row, i) => [...row, vector[i]]);
  
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    for (let k = i + 1; k < n; k++) {
      if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
        maxRow = k;
      }
    }
    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
    
    for (let k = i + 1; k < n; k++) {
      const factor = augmented[k][i] / augmented[i][i];
      for (let j = i; j <= n; j++) {
        augmented[k][j] -= factor * augmented[i][j];
      }
    }
  }
  
  const solution = new Array(n);
  for (let i = n - 1; i >= 0; i--) {
    solution[i] = augmented[i][n];
    for (let j = i + 1; j < n; j++) {
      solution[i] -= augmented[i][j] * solution[j];
    }
    solution[i] /= augmented[i][i];
  }
  
  return solution;
}

function evaluatePolynomial(coefficients, x) {
  let result = 0;
  for (let i = 0; i < coefficients.length; i++) {
    result += coefficients[i] * Math.pow(x, i);
  }
  return result;
}

function generateCompletePeriods(sortedPeriods, aggregation) {
  if (sortedPeriods.length === 0) return [];

  const start = sortedPeriods[0];
  const end = sortedPeriods[sortedPeriods.length - 1];

  const result = [];
  let cursor = start;

  while (cursor <= end) {
    result.push(cursor);
    cursor = nextPeriod(cursor, aggregation);
  }

  return result;
}

function nextPeriod(period, aggregation) {
  if (aggregation === 'monthly') {
    const [y, m] = period.split('-').map(Number);
    const nextM = m === 12 ? 1 : m + 1;
    const nextY = m === 12 ? y + 1 : y;
    return `${nextY}-${String(nextM).padStart(2, '0')}`;
  }

  if (aggregation === 'weekly') {
    const year = Number(period.slice(0, 4));
    const week = Number(period.slice(4)); // YEARWEEK gives YYYYWW
    return week === 53
      ? `${year + 1}01`
      : `${year}${String(week + 1).padStart(2, '0')}`;
  }

  if (aggregation === 'yearly') {
    // For yearly we simply increment year
    const y = Number(period);
    return String(y + 1);
  }

  // default daily (rarely used here)
  return period;
}

// Build maps: company -> color
// Function is able to make colors that aren't too similar to each other

const usedHues = new Set(); // Tracks all assigned hue values

function generateDistinctColor() {
  const saturation = 100;
  const lightness = Math.floor(15 + Math.random() * 5); // 15‚Äì18%

  const minHueDifference = 40; // Enforced strictly

  // Try random hues until a valid one is found
  // With ~360 degrees and 40¬∞ separation, you can safely generate up to ~9 colors.
  while (true) {
    const hue = Math.floor(Math.random() * 360);

    // Check against all used hues
    let ok = true;
    for (const h of usedHues) {
      const diff = Math.abs(h - hue);
      const circularDiff = Math.abs((h - hue + 360) % 360);
      if (diff < minHueDifference || circularDiff < minHueDifference) {
        ok = false;
        break;
      }
    }

    if (ok) {
      usedHues.add(hue);
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // If we spin too long, the palette is exhausted
    if (usedHues.size >= Math.floor(360 / minHueDifference)) {
      throw new Error("No more distinct hues available with this separation.");
    }
  }
}

// Gradient (for points with multiple companies)
function buildPointColors(allLabels, dateCompaniesMap, companyColorMap) {
  return allLabels.map(period => {
    const list = dateCompaniesMap[period] || [];
    const unique = [...new Set(list.filter(x => x))];

    if (unique.length === 0) {
      return '#2196F3';
    }

    if (unique.length === 1) {
      return companyColorMap[unique[0]];
    }

    // Multiple companies ‚Üí plugin draws visible dots
    return 'rgba(0,0,0,0)'; 
  });
}

// Render company color legend
function renderCompanyLegend(companyColorMap) {
  const legendContainers = document.querySelectorAll('.companyLegend');

  // Prepare company list
  const companies = Object.entries(companyColorMap);
  companies.sort((a, b) => a[0].localeCompare(b[0]));

  const half = Math.ceil(companies.length / 2);
  const leftColumn = companies.slice(0, half);
  const rightColumn = companies.slice(half);

  // Helper to build a single column
  function createColumn(list) {
    const col = document.createElement('div');
    col.style.display = 'flex';
    col.style.flexDirection = 'column';
    col.style.gap = '8px';

    list.forEach(([company, color]) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '6px';

      const dot = document.createElement('div');
      dot.style.width = '14px';
      dot.style.height = '14px';
      dot.style.borderRadius = '50%';
      dot.style.backgroundColor = color;
      dot.style.border = '1px solid #333';

      const label = document.createElement('span');
      label.textContent = company;
      label.style.fontSize = '0.9rem';

      row.appendChild(dot);
      row.appendChild(label);
      col.appendChild(row);
    });

    return col;
  }

  // Build the legend for each container
  legendContainers.forEach(container => {
    container.innerHTML = '';

    const wrapper = document.createElement('div');
    wrapper.style.display = 'flex';
    wrapper.style.justifyContent = 'center';
    wrapper.style.gap = '80px';
    wrapper.style.margin = '0 auto';
    wrapper.style.width = 'fit-content';

    wrapper.appendChild(createColumn(leftColumn));
    wrapper.appendChild(createColumn(rightColumn));

    container.appendChild(wrapper);
  });
}

// Wait for both DOM and Chart.js to be ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initChartsWithAggregation('{{query.aggregation}}' || 'monthly'));
} else {
  initChartsWithAggregation('{{query.aggregation}}' || 'monthly');
}

function initChartsWithAggregation(aggregation) {
  console.log('üöÄ Initializing charts...');
  
  if (typeof Chart === 'undefined') {
    console.error('‚ùå Chart.js not loaded');
    const wrapper = document.getElementById('trend-charts-wrapper');
    if (wrapper) {
      wrapper.innerHTML = '<div style="padding:2rem;text-align:center;color:#f44336;">Chart.js failed to load. Please refresh.</div>';
    }
    return;
  }
  
  console.log('‚úÖ Chart.js loaded');

  try {
    const rawData = {{{timeSeriesData}}};
    console.log("RAW ROWS SAMPLE:", rawData.slice(0, 10));
    console.log('üìä Raw data length:', rawData ? rawData.length : 0);
    
    if (!rawData || rawData.length === 0) {
      console.warn('‚ö†Ô∏è No data available');
      const wrapper = document.getElementById('trend-charts-wrapper');
      if (wrapper) {
        wrapper.innerHTML = '<div style="padding:2rem;text-align:center;color:#999;">No time-series data available.</div>';
      }
      return;
    }

    // Build maps: company -> color
    function randomColor() {
      const r = Math.floor(150 + Math.random() * 105);
      const g = Math.floor(150 + Math.random() * 105);
      const b = Math.floor(150 + Math.random() * 105);
      return `rgb(${r}, ${g}, ${b})`;
    }

    const companyColorMap = {};
    const dateCompaniesMap = {}; 
    // Example: { '2024-01-01': ['Company A','Company B'] }

    rawData.forEach(row => {
      // Assign new color if first time seeing company
      if (!companyColorMap[row.company]) {
        companyColorMap[row.company] = randomColor();
      }
      const dateObj = parseFlexibleDate(row.date);
      if (dateObj) {
        let aggKey;

        if (aggregation === 'monthly') {
          aggKey = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}`;
        } else if (aggregation === 'yearly') {
          aggKey = `${dateObj.getFullYear()}`;
        }

        if (!dateCompaniesMap[aggKey]) dateCompaniesMap[aggKey] = [];
        dateCompaniesMap[aggKey].push(row.company);
      }
    });

    // Build company color legend
    renderCompanyLegend(companyColorMap);
    
    const regionName = '{{regionName}}';
    const provinceName = '{{provinceName}}';
    const municipalityName = '{{municipalityName}}';
    const startDate = '{{query.startDate}}' || '';
    const endDate = '{{query.endDate}}' || '';

    // Helper: skip blanks and "ALL"
    const sanitize = v => v && v !== 'ALL';

    // Build location text
    const locationParts = [municipalityName, provinceName, regionName]
      .filter(sanitize);

    const locationText = locationParts.join(', ');

    // Build period text
    let periodText = '';
    if (startDate && endDate) {
      periodText = `from ${startDate} to ${endDate}`;
    } else if (startDate) {
      periodText = `from ${startDate}`;
    } else if (endDate) {
      periodText = `until ${endDate}`;
    }

    // Build chart title
    // "for" only appears if locationText is not empty
    const chartTitleText =
      `Waste Trends${locationText ? ' for ' + locationText : ''}` +
      `${periodText ? ' ' + periodText : ''}`;
    
    const mainTitle = document.getElementById('trends-main-title');
    if (mainTitle) {
      const aggregationLabel = aggregation === 'monthly' ? 'Monthly' : 'Yearly';
      mainTitle.innerHTML = `
        <i class="fa-solid fa-chart-line" style="margin-right: 10px; color: #2196F3;"></i>
        ${chartTitleText}
        <span style="font-size: 0.9rem; color: #666; font-weight: 400; margin-left: 10px;">
          (${aggregationLabel} Averaging Aggregation)
        </span>
        <select id="select-aggregation" style="margin-left: auto; width: 200px;">
          <option value="monthly" ${aggregation === 'monthly' ? 'selected' : ''}>Monthly Summary</option>
          <option value="yearly" ${aggregation === 'yearly' ? 'selected' : ''}>Yearly Summary</option>
        </select>&nbsp;
        <button class="btn-primary" id="applyBtn2">
          <i class="fa-solid fa-check"></i> Apply Filters
        </button>
      `;
      
      const applyBtn2 = document.getElementById('applyBtn2');
      if (applyBtn2) {
        applyBtn2.onclick = () => {
          const newAggregation = document.getElementById('select-aggregation').value;
          // Re-initialize charts with the new aggregation without reloading
          initChartsWithAggregation(newAggregation);
        };
      }
    }
    
    const aggregatedData = aggregateDataWithAveraging(rawData, aggregation);
    const sortedPeriods = Object.keys(aggregatedData).sort();
    const completePeriods = generateCompletePeriods(sortedPeriods, aggregation);

    console.log('üìä Sorted periods:', sortedPeriods.length);
    
    if (sortedPeriods.length === 0) {
      console.warn('‚ö†Ô∏è No periods after aggregation');
      return;
    }
    
    const labels = completePeriods.map(p => formatPeriodLabel(p, aggregation));
    const totalWeights = completePeriods.map(p =>
      aggregatedData[p] ? aggregatedData[p].avgTotalWeight : null
    );
    const perCapitaValues = completePeriods.map(p =>
      aggregatedData[p] ? aggregatedData[p].avgPerCapita : null
    );
    const complianceRates = completePeriods.map(p =>
      aggregatedData[p] ? aggregatedData[p].complianceRate : null
    );
    
    console.log('üìà Data points:', totalWeights.length);
    console.log('üìä Sample weights:', totalWeights.slice(0, 3));
    console.log('üìä Compliance rates:', complianceRates.slice(0, 3));
    
    const xValues = Array.from({ length: totalWeights.length }, (_, i) => i);

    const filteredX = [];
    const filteredY = [];

    for (let i = 0; i < totalWeights.length; i++) {
      if (totalWeights[i] !== null) {
        filteredX.push(i);
        filteredY.push(totalWeights[i]);
      }
    }

    const regression = calculatePolynomialRegression(filteredX, filteredY, 3);

    console.log('üìê Regression R¬≤:', regression.rSquared);
    
    const trendValuesActual = xValues.map(x => evaluatePolynomial(regression.coefficients, x));
    
    const lastPeriod = sortedPeriods[sortedPeriods.length - 1];
    const futurePeriods = generateFutureLabels(lastPeriod, aggregation, 3);
    const futureLabels = futurePeriods.map(p => formatPeriodLabel(p, aggregation));
    const allLabels = [...labels, ...futureLabels];

    const futureX = [totalWeights.length, totalWeights.length + 1, totalWeights.length + 2];
    const futureY = futureX.map(x => evaluatePolynomial(regression.coefficients, x));
    
    const lastX = xValues[xValues.length - 1];
    let derivative = 0;
    for (let i = 1; i < regression.coefficients.length; i++) {
      derivative += i * regression.coefficients[i] * Math.pow(lastX, i - 1);
    }
    
    const regressionStatsEl = document.getElementById('regressionStats');
    if (regressionStatsEl) {
      regressionStatsEl.innerHTML =
        `${derivative > 0 ? 'üìà Increasing' : 'üìâ Decreasing'} trend (${regression.degree}¬∞ polynomial) | 
         R¬≤ = ${(regression.rSquared * 100).toFixed(1)}% | 
         Formula: y(fc) = 1/(T2-T1) √ó Œ£y(i) | 
         Projected at ${futureLabels[2]}: ${futureY[2].toFixed(4)} kg/day`;
    }
    
    // ========== CREATE CHART 1 ==========
    console.log('üé® Creating Chart 1: Total Waste');
    
    const minWidth = 1400;
    const pixelsPerLabel = 50;
    const containerWidth = Math.max(minWidth, allLabels.length * pixelsPerLabel);
    
    const totalWasteContainer = document.getElementById('trendTotalWasteContainer');
    if (totalWasteContainer) {
      totalWasteContainer.style.width = containerWidth + 'px';
      totalWasteContainer.style.minWidth = containerWidth + 'px';
    }
    
    const totalWasteCanvas = document.getElementById('trendTotalWaste');
    if (totalWasteCanvas) {
      // Destroy previous chart instance if it exists
      if (totalWasteCanvas.chartInstance) totalWasteCanvas.chartInstance.destroy();

      const ctx = totalWasteCanvas.getContext('2d');
      if (!ctx) {
        console.error('‚ùå Cannot get canvas context');
        return;
      }

      // Add company colors
      const periodKeys = completePeriods.concat(futurePeriods); // ['2024-01', '2024-02', ...]
      const pointColors = buildPointColors(periodKeys, dateCompaniesMap, companyColorMap, ctx);

      // Detect multiple companies sharing one data point
      const periodCompanySets = periodKeys.map(period => {
        const list = dateCompaniesMap[period] || [];
        // Remove null and duplicates
        const unique = [...new Set(list.filter(x => x))];
        return unique;
      });
      
      const lastTrendValue = evaluatePolynomial(regression.coefficients, totalWeights.length - 1);
      
      const actualData = [...totalWeights, null, null, null];
      const trendData = [...trendValuesActual, null, null, null];
      const projectedTrendData = [
        ...Array(totalWeights.length - 1).fill(null),
        lastTrendValue,
        ...futureY
      ];
      const projectedData = [
        ...Array(totalWeights.length - 1).fill(null),
        lastTrendValue,
        ...futureY
      ];

      console.log("Labels:", allLabels);
      console.log("Period keys:", completePeriods); // or whatever you used
      console.log("DateCompaniesMap:", dateCompaniesMap);

      const MultipleCompanyPointsPlugin = {
        id: 'multiCompanyPoints',
        afterDatasetsDraw(chart, args, opts) {
          const { ctx } = chart;

          const datasetIndex = opts.datasetIndex ?? 0; // your main Actual Data dataset
          const meta = chart.getDatasetMeta(datasetIndex);

          periodCompanySets.forEach((companies, i) => {
            if (companies.length <= 1) return;

            const point = meta.data[i];
            if (!point) return;

            const baseX = point.x;
            const baseY = point.y;

            const radius = 5;
            const spacing = 12; // vertical spacing
            const total = companies.length;

            // Vertically center the stacked dots
            const startOffset = -((total - 1) * spacing) / 2;

            companies.forEach((company, idx) => {
              const color = companyColorMap[company];
              const offsetY = startOffset + idx * spacing;

              ctx.save();
              ctx.beginPath();
              ctx.arc(baseX, baseY + offsetY, radius, 0, Math.PI * 2);
              ctx.fillStyle = color;
              ctx.fill();
              ctx.lineWidth = 1;
              ctx.strokeStyle = color;
              ctx.stroke();
              ctx.restore();
            });
          });
        }
      };
      Chart.register(MultipleCompanyPointsPlugin);
      
      totalWasteCanvas.chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: allLabels,
          datasets: [
            {
              label: 'Actual Data (kg/day)',
              data: actualData,
              borderColor: '#2196F3',
              backgroundColor: '#2196F3',
              pointRadius: 6,
              pointHoverRadius: 8,
              borderWidth: 2,
              fill: false,
              tension: 0.3,
              spanGaps: true,
              // Company point colors
              pointBackgroundColor: pointColors,
              pointBorderColor: pointColors,
              pointBorderWidth: 1
            },
            {
              label: 'Trend Line (Actual)',
              data: trendData,
              borderColor: '#FF5722',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 5,
              spanGaps: true
            },
            {
              label: 'Trend Line (Projected)',
              data: projectedTrendData,
              borderColor: '#FF5722',
              borderWidth: 3,
              borderDash: [8, 4],
              fill: false,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 5,
              spanGaps: true
            },
            {
              label: 'Projected Values',
              data: projectedData,
              borderColor: '#FFA000',
              backgroundColor: 'rgba(255, 160, 0, 0.15)',
              borderDash: [8, 4],
              fill: 'origin',
              tension: 0.4,
              pointRadius: 6,
              pointBackgroundColor: '#FFA000',
              pointBorderColor: '#fff',
              pointBorderWidth: 2,
              borderWidth: 3,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: { 
              position: 'top',
              labels: {
                font: { size: 12 },
                usePointStyle: true,
                padding: 15
              }
            },
            title: {
              display: true,
              text: 'Total Waste Generation with Polynomial Regression',
              font: { size: 14, weight: 'bold' },
              color: '#2d613f',
              padding: { top: 10, bottom: 20 }
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  if (context.parsed.y === null) return '';

                  const date = context.label;
                  const comps = dateCompaniesMap[date] || [];

                  let companyList = '';
                  if (comps.length > 0) {
                    companyList = ' | Companies: ' + comps.join(', ');
                  }

                  return `${context.dataset.label}: ${context.parsed.y.toFixed(4)} kg/day${companyList}`;
                }
              }
            }
          },
          scales: {
            y: { 
              ticks: {
                font: { size: 11 }
              },
              title: { 
                display: true, 
                text: 'Weight (kg/day)',
                font: { weight: 'bold', size: 12 }
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            },
            x: { 
              title: { 
                display: true, 
                text: `Period (${aggregation})`,
                font: { weight: 'bold', size: 12 }
              },
              ticks: { 
                maxRotation: 45, 
                minRotation: 45,
                autoSkip: false,
                font: { size: 10 }
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              }
            }
          },
          layout: {
            padding: {
              left: 10,
              right: 30,
              top: 10,
              bottom: 10
            }
          }
        }
      });
      console.log('‚úÖ Chart 1 created');
    }
    
    // ========== CREATE CHART 2 ==========
    console.log('üé® Creating Chart 2: Per Capita');
    
    const perCapitaWidth = Math.max(1200, labels.length * 100);
    const perCapitaContainer = document.getElementById('trendPerCapitaContainer');
    if (perCapitaContainer) {
      perCapitaContainer.style.width = perCapitaWidth + 'px';
      perCapitaContainer.style.minWidth = perCapitaWidth + 'px';
    }
    
    const perCapitaCanvas = document.getElementById('trendPerCapita');
    if (perCapitaCanvas) {
      // Destroy previous chart instance if it exists
      if (perCapitaCanvas.chartInstance) perCapitaCanvas.chartInstance.destroy();

      perCapitaCanvas.chartInstance = new Chart(perCapitaCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Per Capita Waste',
            data: perCapitaValues,
            borderColor: '#FF9800',
            backgroundColor: 'rgba(255, 152, 0, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 5,
            borderWidth: 3,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top' },
            title: {
              display: true,
              text: 'Per Capita Waste Trend',
              font: { size: 14, weight: 'bold' },
              color: '#2d613f'
            }
          },
          scales: {
            y: { 
              title: { display: true, text: 'kg/cap-day¬≤' },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            },
            x: { 
              title: { display: true, text: `Period (${aggregation})` }, 
              ticks: { maxRotation: 45, minRotation: 45, autoSkip: false },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            }
          },
          layout: {
            padding: { left: 10, right: 30, top: 10, bottom: 10 }
          }
        }
      });
      console.log('‚úÖ Chart 2 created');
    }
    
    // ========== CREATE/UPDATE CHART 3 ==========
    console.log('üé® Creating Chart 3: By Category');

    const categoryCanvas = document.getElementById('trendByCategory');
    if (categoryCanvas) {
      const categories = ['Biodegradable', 'Recyclable', 'Residual', 'Special/Hazardous'];
      const categoryColors = {
        'Biodegradable': 'rgba(76, 175, 80, 0.8)',
        'Recyclable': 'rgba(33, 150, 243, 0.8)',
        'Residual': 'rgba(158, 158, 158, 0.8)',
        'Special/Hazardous': 'rgba(244, 67, 54, 0.8)'
      };
      
      const categoryDatasets = categories.map(cat => {
        return {
          label: cat,
          data: sortedPeriods.map(p => (aggregatedData[p]?.wasteByCategory[cat] || 0) / aggregatedData[p].timeSpan),
          backgroundColor: categoryColors[cat],
          borderColor: categoryColors[cat].replace('0.8', '1'),
          borderWidth: 2,
          fill: true,
          tension: 0.4
        };
      });

      // Destroy previous chart instance if exists
      if (categoryCanvas.chartInstance) categoryCanvas.chartInstance.destroy();

      categoryCanvas.chartInstance = new Chart(categoryCanvas.getContext('2d'), {
        type: 'line',
        data: { labels: labels, datasets: categoryDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top' },
            title: {
              display: true,
              text: 'Waste by Category',
              font: { size: 14, weight: 'bold' },
              color: '#2d613f'
            }
          },
          scales: {
            y: { stacked: true, title: { display: true, text: 'Weight (kg/day)' } },
            x: { stacked: true, title: { display: true, text: `Period (${aggregation})` } }
          }
        }
      });
      console.log('‚úÖ Chart 3 created');
    }
    
    // ========== CREATE CHART 4 - WITH RETRIEVAL ==========
    console.log('üé® Creating Chart 4: Compliance');
    
    const complianceWidth = Math.max(1200, labels.length * 100);
    const complianceContainer = document.getElementById('trendComplianceContainer');
    if (complianceContainer) {
      complianceContainer.style.width = complianceWidth + 'px';
      complianceContainer.style.minWidth = complianceWidth + 'px';
    }
    
    const complianceCanvas = document.getElementById('trendCompliance');
    if (complianceCanvas) {
      // Destroy previous chart instance if it exists
      if (complianceCanvas.chartInstance) complianceCanvas.chartInstance.destroy();

      complianceCanvas.chartInstance = new Chart(complianceCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Compliance Rate (%)',
            data: complianceRates,
            borderColor: '#2196F3',
            backgroundColor: 'rgba(33, 150, 243, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 5,
            borderWidth: 3,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top' },
            title: {
              display: true,
              text: 'Compliance Rate Trend (4 Categories + 6 Sectors per Entry)',
              font: { size: 14, weight: 'bold' },
              color: '#2d613f'
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const periodKey = sortedPeriods[context.dataIndex];
                  const data = aggregatedData[periodKey];
                  const numEntries = data.totalComplianceItems / 10;
                  
                  return [
                    `Compliance: ${context.parsed.y.toFixed(1)}%`,
                    `Data Entries: ${numEntries}`,
                    `Total Items: ${data.totalComplianceItems} (10 per entry)`,
                    `Compliant: ${data.compliantItems}`
                  ];
                }
              }
            }
          },
          scales: {
            y: { 
              min: 0,
              max: 100,
              title: { display: true, text: 'Compliance Rate (%)' },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            },
            x: { 
              title: { display: true, text: `Period (${aggregation})` }, 
              ticks: { maxRotation: 45, minRotation: 45, autoSkip: false },
              grid: { color: 'rgba(0, 0, 0, 0.05)' }
            }
          },
          layout: {
            padding: { left: 10, right: 30, top: 10, bottom: 10 }
          }
        }
      });
      console.log('‚úÖ Chart 4 created');
    }
    
    console.log('‚úÖ All charts initialized successfully');
    
  } catch (error) {
    console.error('‚ùå Error initializing charts:', error);
    console.error('Stack:', error.stack);
  }
}
</script>

<!-- Pie chart script -->
<script>

const summaryData = {{{summaryPieData}}},
      detailedData = {{{detailedPieData}}},
      barChartData = {{{barChartData}}},
      sectorBarData = {{{sectorBarData}}},
      sectorPieData = {{{sectorPieData}}};

const supertypeDemo = {{{supertypeDemo}}};
const grandTotal = {{{grandTotal}}};

const rand = arr => arr[Math.floor(Math.random() * arr.length)];
const pct = (value, total) => total ? (value / total * 100) : 0;
const fmtKg = (n) => `${Number(n).toFixed(3)} kg`;

const overallPhrases = {
  balanced:
    "All major categories are nearly proportional, indicating a balanced waste composition with no single dominant source.<br><br>",
  dominant:
    "One category dominates the waste stream. Prioritize source reduction and targeted segregation for this category.<br><br>",
  lowReported:
    "Some categories show very low or missing volumes. This may be caused by underreporting, misclassification, gaps in reporting, or genuinely low output.<br><br>",
  mixedDominant:
    "Several categories contribute significant amounts. Consider combined campaigns (e.g., recycling + organics) rather than programs for a single type.<br><br>"
};

const overallRecommendations = {
  Biodegradable: "Enhance composting initiatives and promote household segregation of organics.",
  Recyclable: "Expand recycling collection routes and promote local recycling markets.",
  Residual: "Reduce single-use packaging as much as possible. Encourage proper containment of sanitary waste and explore recovery options (e.g., co-processing) for non-recyclables like wrappers, textiles, and ceramics.",
  "Special/Hazardous": "Implement safe collection and disposal protocols, raise awareness on proper handling, and coordinate with authorized hazardous waste facilities."
};

function generateOverallInsight(supertypeMapObj, grandTotalVal) {
  const supertypes = Object.values(supertypeMapObj);
  const nonzero = supertypes.filter(s => Number(s.totalWeight) > 0);
  const shares = supertypes.map(s => ({
    name: s.name,
    value: Number(s.totalWeight),
    pct: pct(Number(s.totalWeight), grandTotalVal)
  }));
  shares.sort((a,b)=>b.pct-a.pct);

  if (grandTotalVal === 0) {
    return "No waste data recorded for this entry. Please verify and recheck data submissions.";
  }

  const top = shares[0];
  const second = shares[1] || null;
  const avgPct = shares.reduce((a,b)=>a+b.pct,0)/shares.length;
  const deviations = shares.map(s => Math.abs(s.pct - avgPct));
  const allBalanced = deviations.every(d => d < 5);

  const lowList = shares.filter(s => s.pct < 2).map(s => s.name);
  const tinyList = shares.filter(s => s.pct < 10).map(s => s.name);

  const fullBreakdown = shares.map(s => `${s.name}: ${s.pct.toFixed(1)}%`).join(', ');

  let insightText = "";
  let recHTML = "";

  if (allBalanced && nonzero.length > 2) {
    insightText = overallPhrases.balanced;
    if (lowList.length) insightText += ` However, some categories appear minimal: ${lowList.join(', ')}.`;
    if (tinyList.length === 1) insightText += ` The category ${tinyList[0]} is noticeably small compared to others.`;
  }

  else if (top.pct >= 50) {
    insightText = `${overallPhrases.dominant} Currently, <strong>${top.name}</strong> represents ${top.pct.toFixed(1)}% of the total.`;
    if (lowList.length) insightText += ` Some low categories: ${lowList.join(', ')}.`;
    if (tinyList.length === 1) insightText += ` The category ${tinyList[0]} is noticeably small compared to others.`;

    if (overallRecommendations[top.name]) {
      recHTML = `
        <div class="recommendation-box">
        <span>
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <b style='color:#2d613f;'>${top.name.toUpperCase()}</b><br>
          ${overallRecommendations[top.name]}
        </span>
        </div>
      `;
    }
  }

  else if (shares.filter(s => s.pct >= 20).length >= 2 &&
         shares.filter(s => s.pct >= 20).length <= 3) {
    const strongList = shares.filter(s => s.pct >= 20);
    insightText = `${overallPhrases.mixedDominant} <b>Major categories: ${strongList.map(s => s.name).join(', ')}</b>`;

    recHTML = strongList
      .filter(s => overallRecommendations[s.name])
      .map(s => `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
          <b style='color:#2d613f;'>${s.name.toUpperCase()}</b><br>
          ${overallRecommendations[s.name]}
          </span>
        </div>
      `)
      .join('');
  }

  else if (lowList.length === shares.length) {
    insightText = "All categories show minimal values; likely incomplete or unreported data.";
  }

  else if (lowList.length) {
    insightText = `${overallPhrases.lowReported} Notably low: ${lowList.join(', ')}.`;
  }

  else {
    const uniquePattern = new Set(shares.map(s => Math.round(s.pct / 5) * 5)).size === shares.length;
    if (uniquePattern && !allBalanced && top.pct < 50) {
      insightText = "Each category has a distinct share, showing a varied waste composition with no single type dominating.";
      if (tinyList.length) insightText += ` The category ${tinyList.join(', ')} has smaller proportions than others.`;
    } else {
      insightText = "The waste composition shows a mixed pattern without extreme concentrations. Continue tracking for shifts over time.";
    }
  }

  return `${insightText}${recHTML}`;
}

function generateSupertypeInsight(supertypeObj, grandTotalVal) {
  const types = supertypeObj.types || [];
  const total = Number(supertypeObj.totalWeight) || 0;
  if (!total || !types.length) {
    return `No data recorded for <strong>${supertypeObj.name}</strong>. Verify reporting for this category.`;
  }

  const pairs = types.map(t => ({
    name: t.name,
    value: Number(t.weight) || 0
  })).sort((a, b) => b.value - a.value);

  const top = pairs[0];
  const second = pairs[1] || null;
  const avgVal = pairs.reduce((a, b) => a + b.value, 0) / pairs.length;
  const allBalanced = pairs.every(p => Math.abs(p.value - avgVal) < avgVal * 0.05);
  const lowList = pairs.filter(p => p.value < avgVal * 0.2).map(p => p.name);
  const highList = pairs.filter(p => p.value >= avgVal * 1.2);

  const recs = {
    Biodegradable: {
      "Food / Kitchen Waste": "Promote household and commercial composting, and encourage portion control to minimize food waste.",
      "Agricultural Waste": "Encourage conversion into compost or animal feed.",
      "Animal / Livestock Waste": "Implement safe manure management where feasible.",
      "Garden / Park Waste": "Set up community composting areas or mulching programs.",
      "Vegetable and Fruit Peelings": "Encourage home composting and segregation from residuals.",
      "Other (Biodegradable)": "Ensure clear segregation and consider composting methods or biomass processing."
    },
    Recyclable: {
      "Polyethylene Terephthalate (PET)": "Enhance PET bottle collection drives and link with recycling facilities.",
      "Office Paper": "Encourage adoption of paperless systems.",
      "Corrugated Cardboard": "Encourage reuse for packaging and bulk recycling in business establishments.",
      "Glass": "Set up collection for glass containers and support bottle return programs.",
      "Newspaper": "Encourage reuse or bulk recycling, especially from offices and stores.",
      "Polyvinyl Chloride (PVC)": "Coordinate with accredited recyclers; discourage open burning.",
      "Polypropylene (PP)": "Support sorting programs to recover PP plastics (e.g., bottle caps, containers).",
      "Aluminum": "Promote aluminum recycling; used metals may be molten and reused for production of cans, car parts, or construction materials.",
      "High-density polyethylene (HDPE)": "Facilitate recovery and proper cleaning for reuse or recycling.",
      "Tin Cans": "Encourage collection through metal recyclers; avoid disposal with residual waste.",
      "Low-density polyethylene (LDPE)": "Minimize single-use plastics; promote use of thicker, reusable alternatives.",
      "Polystyrene (PS)": "Discourage styrofoam use and support recycling alternatives.",
      "Other (Recyclable)": "Clarify labeling and strengthen material recovery facility (MRF) sorting."
    },
    Residual: {
      "Wrappers / Sachets": "Advocate for reduction of single-use plastics.",
      "Sanitary Napkins / Diapers": "Enforce proper segregation and explore biodegradable alternatives.",
      "Textiles / Fabrics": "Encourage clothing donation or repurposing; reduce textile waste.",
      "Rubber": "Coordinate with facilities that repurpose or process rubber materials.",
      "Ceramics": "Promote reuse in construction filler applications or proper disposal.",
      "Other (Residual)": "Focus on waste reduction at source and explore alternative disposal technologies."
    },
    "Special/Hazardous": {
      "Healthcare Waste": "Ensure collection and treatment through accredited hazardous waste handlers.",
      "Bulky Waste": "Coordinate scheduled pickup or reuse programs for furniture and appliances.",
      "Tires": "Explore reuse for playground or construction materials; avoid open burning.",
      "Paints / Thinners": "Handle as hazardous; ensure separate storage and disposal.",
      "Oil": "Encourage oil recycling or proper collection by accredited facilities. Used oil can be re-refined into lubricants, fuel, and raw materials for petrochemical industries.",
      "Consumer Electronics / Black Goods": "Establish e-waste collection drives and proper recycling channels.",
      "Household Appliances / White Goods": "Coordinate with repair/reuse programs and e-waste recyclers.",
      "Household Batteries": "Promote safe collection points for used batteries.",
      "Other (Special / Hazardous)": "Promote segregation, labeling, and proper disposal."
    }
  };

  const getRecommendation = (dominantList, supertype) => {
    const rset = recs[supertype] || {};
    const blocks = dominantList
      .map(t => {
        const recText = rset[t.name];
        if (!recText) return null;
        return `
          <div class="recommendation-box">
            <span>
              <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
              <b style='color:#2d613f;'>${t.name.toUpperCase()}</b><br>
              ${recText}
            </span>
          </div>
        `;
      })
      .filter(Boolean)
      .join("");
    return blocks ? `<br>${blocks}` : "";
  };

  if (allBalanced) {
    let text = `Types under <strong>${supertypeObj.name}</strong> have nearly equal distribution.`;
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  if (second && top.value >= second.value * 1.5) {
    let text = `<strong>${top.name}</strong> dominates this category (${top.value.toFixed(1)} kg).`;
    text += getRecommendation([top], supertypeObj.name);
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  const topTwoAvg = (top.value + (second?.value || 0)) / 2;
  if (
    pairs.length >= 2 &&
    top.value >= avgVal * 1.2 &&
    second.value >= avgVal * 1.2 &&
    top.value / second.value < 1.3
  ) {
    let text = `Two main types lead in ${supertypeObj.name}: <b>${top.name}</b> (${top.value.toFixed(1)} kg) and <b>${second.name}</b> (${second.value.toFixed(1)} kg).`;
    text += getRecommendation([top, second], supertypeObj.name);
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  if (highList.length >= 3 && highList.length < pairs.length) {
    let text = `Several types stand out within ${supertypeObj.name}: <b>${highList.map(p => p.name).join(', ')}</b>.`;
    text += getRecommendation(highList, supertypeObj.name);
    if (lowList.length) text += `<br>Lower types: <b>${lowList.join(', ')}</b>.`;
    return text;
  }

  if (lowList.length && lowList.length >= pairs.length - 1) {
    return `Most types under <strong>${supertypeObj.name}</strong> are minimal. This may be caused by low generation or incomplete entries (${lowList.join(', ')}).`;
  }

  return `The <strong>${supertypeObj.name}</strong> category shows varied distribution across its types.`;
}

function generateSectorInsight(sectorName, pieDataForSector, sectorTotalValue, grandTotalVal) {
  const labels = pieDataForSector.labels || [];
  const data = pieDataForSector.data || [];
  const pairs = labels.map((l,i) => ({
    label: l,
    value: data[i],
    pct: pct(data[i], sectorTotalValue)
  }));
  pairs.sort((a,b)=>b.pct-a.pct);

  if (sectorTotalValue === 0) {
    return `${sectorName} has no recorded waste. Please check reporting completeness.`;
  }

  const formatList = arr => {
    if (!arr.length) return '';
    const bolded = arr.map(l => `<b>${l}</b>`);
    if (bolded.length === 1) return bolded[0];
    if (bolded.length === 2) return `${bolded[0]} and ${bolded[1]}`;
    return `${bolded.slice(0, -1).join(', ')}, and ${bolded[bolded.length - 1]}`;
  };

  const avgPct = pairs.reduce((a,b)=>a+b.pct,0)/pairs.length;
  const allBalanced = pairs.every(p => Math.abs(p.pct - avgPct) < 5);
  const top = pairs[0];
  const second = pairs[1] || null;
  const lowList = pairs.filter(p => p.pct < 2).map(p => p.label);
  const tinyList = pairs.filter(p => p.pct < 10).map(p => p.label);

  let insight = '';
  let recHTML = '';

  if (allBalanced && pairs.length > 2) {
    insight = `Waste in the ${sectorName} sector is evenly distributed among all categories.`;
    if (lowList.length) insight += ` However, some categories appear minimal: ${formatList(lowList)}.`;
    if (tinyList.length === 1) insight += ` The ${formatList(tinyList)} category is noticeably small compared to others.`;
  }

  else if (top.pct >= 50) {
    insight = `<b>${top.label}</b> dominates waste generation in the ${sectorName} sector (${top.pct.toFixed(1)}%).`;
    if (lowList.length) insight += ` Other categories remain minimal: ${formatList(lowList)}.`;
    if (tinyList.length === 1) insight += ` The category ${formatList(tinyList)} shows an especially small share.`;

    if (overallRecommendations[top.label]) {
      recHTML = `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style='color:#2d613f;'>${top.label.toUpperCase()}</b><br>
            ${overallRecommendations[top.label]}
          </span>
        </div>
      `;
    }
  }

  else if (pairs.filter(p => p.pct >= 20).length >= 2 && pairs.filter(p => p.pct >= 20).length < pairs.length) {
    const majors = pairs.filter(p => p.pct >= 20).map(p => p.label);
    insight = `Dominant waste types in the ${sectorName} sector are ${formatList(majors)}, sharing most of the total volume.`;
    if (lowList.length) insight += ` Smaller portions are seen in ${formatList(lowList)}.`;
    if (tinyList.length === 1) insight += ` The category ${formatList(tinyList)} has a noticeably small share.`;

    recHTML = majors
      .filter(l => overallRecommendations[l])
      .map(l => `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style='color:#2d613f;'>${l.toUpperCase()}</b><br>
            ${overallRecommendations[l]}
          </span>
        </div>
      `)
      .join('');
  }

  else if (lowList.length === pairs.length) {
    insight = `All categories in the ${sectorName} sector show minimal proportions. This may indicate incomplete or underreported data.`;
  } else if (lowList.length) {
    insight = `Most waste types in the ${sectorName} sector have relatively low proportions. Notably low: ${formatList(lowList)}.`;
  }

  else {
    const uniquePattern = new Set(pairs.map(p => Math.round(p.pct / 5) * 5)).size === pairs.length;
    if (uniquePattern && !allBalanced && top.pct < 50) {
      insight = `Waste distribution in the ${sectorName} sector varies across all categories with no clear dominant type.`;
      if (tinyList.length) insight += ` The category ${formatList(tinyList)} appears smaller in comparison.`;
    } else {
      insight = `The ${sectorName} sector shows a mixed pattern across categories without clear extremes.`;
      if (tinyList.length) insight += ` ${formatList(tinyList)} remains relatively small.`;
    }
  }

  return `${insight}${recHTML}`;
}

function generateSectorOverviewInsight(sectorBarArr, grandTotalVal) {
  const validSectors = (sectorBarArr || []).filter(s => Number(s.value) > 0);
  if (!validSectors.length || grandTotalVal === 0) {
    return "No sector data recorded. Please verify that sector totals were generated correctly.";
  }

  const pct = (v, t) => (t ? (v / t) * 100 : 0);

  const shares = validSectors.map(s => ({
    name: s.label,
    value: Number(s.value),
    pct: pct(Number(s.value), grandTotalVal)
  })).sort((a, b) => b.pct - a.pct);

  const top = shares[0];
  const second = shares[1] || null;
  const topPct = top ? top.pct : 0;
  const lowList = shares.filter(s => s.pct < 2).map(s => s.name);
  const avgPct = shares.reduce((a, b) => a + b.pct, 0) / shares.length;
  const allBalanced = shares.every(s => Math.abs(s.pct - avgPct) < 5);

  let insight = "";
  let recHTML = "";

  const sectorRecommendations = {
    Residential: "Focus on household waste segregation, composting, and localized recycling programs.",
    Commercial: "Promote waste audits for establishments and enforce segregation-at-source policies in markets, restaurants, and shops.",
    Institutional: "Integrate waste reduction and segregation practices in offices, schools, and government facilities.",
    Industrial: "Encourage waste minimization and proper handling of industrial by-products.",
    "Agriculture and Livestock": "Support composting, manure management, and proper segregation of agricultural residue.",
    Health: "Ensure proper segregation of biomedical waste and coordinate with authorized hazardous waste treatment facilities."
  };

  if (grandTotalVal === 0) {
    return "No waste totals found. Cannot determine sector distribution.";
  }

  if (allBalanced && shares.length >= 3) {
    return "Waste generation is fairly balanced across sectors; no single area stands out as dominant.";
  }

  if (topPct >= 50) {
    insight = `<strong>${top.name}</strong> is the largest contributor, producing ${top.pct.toFixed(1)}% of all recorded waste.`;
    if (lowList.length) insight += ` Sectors with low generation include <b>${lowList.join(', ')}</b>.`;

    if (sectorRecommendations[top.name]) {
      recHTML = `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style="color:#2d613f;">${top.name.toUpperCase()}</b><br>
            ${sectorRecommendations[top.name]}
          </span>
        </div>
      `;
    }

    return `${insight}${recHTML}`;
  }

  if (topPct >= 30 && topPct < 50 && second && Math.abs(top.pct - second.pct) < 10) {
    const majorSectors = shares.filter(s => s.pct >= 30);
    insight = `Waste generation is shared across multiple sectors, led by ${majorSectors.map(s => `<strong>${s.name}</strong>`).join(' and ')}.`;
    if (lowList.length) insight += ` Some smaller sectors include <b>${lowList.join(', ')}</b>.`;

    recHTML = majorSectors
      .filter(s => sectorRecommendations[s.name])
      .map(s => `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style="color:#2d613f;">${s.name.toUpperCase()}</b><br>
            ${sectorRecommendations[s.name]}
          </span>
        </div>
      `)
      .join('');

    return `${insight}${recHTML}`;
  }

  const isGradual = shares.every((s, i, arr) => !i || arr[i - 1].pct - s.pct < 8);
  if (isGradual && !allBalanced && shares.length > 3) {
    insight = `A gradual decline in waste generation is observed across sectors, with <b>${top.name}</b> contributing the most and <b>${shares[shares.length - 1].name}</b> the least.`;
    if (lowList.length) insight += ` Some sectors have minimal values such as <b>${lowList.join(', ')}</b>.`;
    
    if (sectorRecommendations[top.name]) {
      recHTML = `
        <div class="recommendation-box">
          <i class="fas fa-lightbulb" style="color:#ffb300;margin-right:0.5rem;"></i>
          <span>
            <b style="color:#2d613f;">${top.name.toUpperCase()}</b><br>
            ${sectorRecommendations[top.name]}
          </span>
        </div>
      `;
    }

    return `${insight}${recHTML}`;
  }

  const hasSteps = shares.some((s, i) => i && shares[i - 1].pct - s.pct >= 10);
  if (hasSteps && !isGradual) {
    insight = `Waste generation by sector follows a stepped pattern where certain sectors contribute significantly more than others.`;
    if (lowList.length) insight += ` The smallest contributors are <b>${lowList.join(', ')}</b>.`;
    return insight;
  }

  if (lowList.length) {
    return `Some sectors show minimal contribution (below 2%): <b>${lowList.join(', ')}</b>.`;
  }

  return "Sector contributions appear proportionate. Continue monitoring to identify future trends.";
}

function insertOverallInsight() {
  try {
    const overallText = generateOverallInsight(supertypeDemo || {}, Number(grandTotal || 0));
    const container = document.getElementById('summary-insight');

    if (container) {
      let box = container.querySelector('.insight-box.overall');
      if (!box) {
        box = document.createElement('div');
        box.className = 'insight-box overall';
        box.style = 'margin-top:1rem; padding:1rem; border-left:4px solid #2e7d32;background:#f7fff8; border-radius:6px;';
        container.appendChild(box);
      }
      box.innerHTML = `<h3 style="margin:0 0 0.25rem 0;color:#2d613f">Quick Recommendation</h3><div>${overallText}</div>`;
    }
  } catch (err) {
    console.error('Overall insight generation failed', err);
  }
}

function insertPerSupertypeInsights() {
  try {
    const superMap = supertypeDemo || {};
    for (const sv of Object.values(superMap)) {
      const id = sv.name.replace(/\s+/g, '');
      const wrapper = document.getElementById(id);

      if (!wrapper) continue;

      let box = wrapper.querySelector('.bar-description');
      if (!box) {
        box = document.createElement('div');
        wrapper.appendChild(box);
      }
      box.innerHTML = `<h3 style="margin:0 0 0.25rem 0;color:#2d613f">${sv.name}</h3><div>${generateSupertypeInsight(sv, Number(grandTotal || 0))}</div>`;
    }
  } catch (err) { console.error(err); }
}

function insertSectorInsights() {
  try {
    for (const [sectorName, pieData] of Object.entries(sectorPieData || {})) {
      const id = sectorName.replace(/\s+/g, '');
      const wrapper = document.getElementById(id);

      if (!wrapper) continue;
      let box = wrapper.querySelector('.sector-pie-desc');

      if (!box) {
        box = document.createElement('div');
        wrapper.appendChild(box);
      }
      const sectorTotalVal = (sectorBarData || []).find(s=>s.label===sectorName)?.value || 0;
      box.innerHTML = `<h3 style="margin:0 0 0.25rem 0;color:#2d613f">Sector Insights</h3><div>${generateSectorInsight(sectorName, pieData, Number(sectorTotalVal || 0), Number(grandTotal || 0))}</div>`;
    }
  } catch (err) { console.error(err); }
}

function insertSectorOverviewInsight() {
  try {
    const container = document.getElementById('sector-insight');
    if (!container) return;

    const insightText = generateSectorOverviewInsight(sectorBarData || [], Number(grandTotal || 0));
    
    let box = container.querySelector('.sector-overview');
    if (!box) {
      box = document.createElement('div');
      box.className = 'sector-overview';
      box.style = 'margin-top:1rem; padding:1rem; border-left:4px solid #2e7d32;background:#f7fff8; border-radius:6px;';
      container.appendChild(box);
    }

    box.innerHTML = `
      <h3 style="margin:0 0 0.25rem 0;color:#2d613f">Sector Overview</h3>
      <div>${insightText}</div>
    `;
  } catch (err) {
    console.error('Sector overview insight generation failed', err);
  }
}

let currentMode = 'summary';
const ctx = document.getElementById('supertypePieChart').getContext('2d');

const baseWidth = 600;
const baseHeight = 600;
const detailedExtraHeight = 250;

const createPieChart = (data, mode) => {
  const canvas = document.getElementById('supertypePieChart');
  canvas.width = baseWidth;
  canvas.height = mode === 'detailed'
    ? baseHeight + detailedExtraHeight
    : baseHeight;

  return new Chart(canvas.getContext('2d'), {
    type: 'pie',
    data: {
      labels: data.labels,
      datasets: [{
        data: data.data,
        backgroundColor: data.backgroundColor,
        hoverOffset: 20
      }]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          callbacks: {
            label: ({ raw, label, chart }) => {
              const total = chart._metasets[0].total || 1;
              const percent = ((raw / total) * 100).toFixed(3);
              return `${label}: ${Number(raw).toFixed(3)} kg (${percent}%)`;
            }
          }
        },
        legend: {
          display: mode === 'detailed',
          position: 'bottom',
          labels: {
            boxWidth: 20,
            padding: 10
          }
        },
        title: { display: false }
      },
      layout: {
        padding: {
          bottom: mode === 'detailed' ? detailedExtraHeight - 100 : 0
        }
      },
      cutout: 0,
      radius: mode === 'summary' ? '80%' : '100%'
    },
    plugins: [{
      id: 'multiColumnLegend',
      afterUpdate(chart) {
        const chartArea = chart.chartArea;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2 - (mode === 'detailed' ? 60 : 0); 
        chart._metasets.forEach(meta => {
          meta.controller.outerRadius = meta.controller.chart.radius;
          meta.controller.chartArea = chartArea;
          meta.controller.xCenter = centerX;
          meta.controller.yCenter = centerY;
        });

        if (mode !== 'detailed') return;

        const legend = chart.legend;
        if (!legend) return;

        const items = legend.legendItems;
        const mid = Math.ceil(items.length / 2);
        const firstCol = items.slice(0, mid);
        const secondCol = items.slice(mid);

        legend.draw = function() {
          const ctx = chart.ctx;
          const font = Chart.helpers.toFont(legend.options.labels.font);
          ctx.font = font.string;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';

          const lineHeight = font.lineHeight + 6;
          const colSpacing = chart.width / 2.5;
          const startY = chart.chartArea.bottom + 30;
          const legendLeftMargin = 60;

          const drawColumn = (col, x) => {
            col.forEach((item, i) => {
              const y = startY + i * lineHeight;
              ctx.fillStyle = item.fillStyle;
              ctx.fillRect(x, y - 5, 12, 12);
              ctx.fillStyle = item.textColor;
              ctx.fillText(item.text, x + 18, y + 2);
            });
          };

          drawColumn(firstCol, chart.chartArea.left + legendLeftMargin);
          drawColumn(secondCol, chart.chartArea.left + colSpacing + legendLeftMargin);
        };
      }
    }]
  });
};

let chart = createPieChart(summaryData, 'summary');

const togglePieBtn = document.getElementById('togglePieBtn');
if (togglePieBtn) {
  togglePieBtn.addEventListener('click', () => {
    chart.destroy();
    currentMode = currentMode === 'summary' ? 'detailed' : 'summary';
    chart = createPieChart(
      currentMode === 'summary' ? summaryData : detailedData,
      currentMode
    );
    togglePieBtn.innerHTML = currentMode === 'summary'
      ? '<i class="fa-solid fa-circle-info"></i>&nbsp; Show Detailed Pie Chart'
      : '<i class="fa-solid fa-chart-pie"></i>&nbsp; Back to Summary Pie Chart';
  });
}

const createLegendHTML = (legendData, dataset) => {
  const total = dataset.reduce((a, b) => a + b, 0);
  return legendData
    .filter(item => item.value > 0)
    .map(item => {
      const pct = total ? ((item.value / total) * 100).toFixed(3).replace(/\.0+$/, '') : '0';
      return `<span class="legend-item" style="background-color: ${item.color}">
        <span class="bar-legend-name">
          ${item.label}
          <span class="bar-legend-perc">${pct}%</span>
        </span>
        <span class="bar-legend-kg">
          ${item.value.toFixed(3)} kg
        </span>
      </span>`;
    }).join('');
};

// ========== BAR CHARTS BY WASTE TYPE ========== //
const container = document.getElementById('bar-charts-container');

for (const [supertype, chartData] of Object.entries(barChartData)) {
  const tabDiv = document.createElement('div');
  tabDiv.id = supertype.replace(/\s+/g, '');
  tabDiv.classList.add('bar-tabcontent');
  tabDiv.setAttribute('data-section', `types-${supertype.toLowerCase()}`);

  const headerDiv = document.createElement('div');
  headerDiv.classList.add('bar-header');
  headerDiv.innerHTML = `
    <h2 class="bar-legend-title">Top ${supertype} Waste Types</h2>
    <div class="bar-description" 
         style="background-color: #eef8f2; padding: 1rem; border-radius: 12px;
                border-left: 6px solid #4CAF50; margin-bottom: 1rem; width: 100%;
                box-sizing: border-box;">
    </div>
  `;

  const chartDiv = document.createElement('div');
  chartDiv.classList.add('bar-chart-wrapper');
  chartDiv.style.cssText = 'display: flex; justify-content: center; align-items: center; margin-bottom: 1.5rem;';

  const canvas = document.createElement('canvas');
  canvas.id = `barChart-${supertype.replace(/\s+/g, '-')}`;
  canvas.classList.add('bar-canvas');
  canvas.style.marginBottom = '0';

  chartDiv.appendChild(canvas);

  const legendDiv = document.createElement('div');
  legendDiv.classList.add('bar-legend-container');
  legendDiv.style.cssText = `
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: flex-start;
    justify-content: center;
  `;
  legendDiv.innerHTML = createLegendHTML(chartData.legend, chartData.data);

  tabDiv.append(headerDiv, chartDiv, legendDiv);
  container.appendChild(tabDiv);

  new Chart(canvas.getContext('2d'), {
    type: 'bar',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: `${supertype} Waste Types`,
        data: chartData.data,
        backgroundColor: chartData.legend.map(i => i.color)
      }]
    },
    options: {
      animation: { duration: 0 },
      responsive: true,
      indexAxis: 'x',
      plugins: {
        tooltip: {
          callbacks: {
            label: ({ parsed }) => `${parsed.y.toFixed(3)} kg`
          }
        },
        title: { display: false }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Weight (kg)' }
        },
        x: {
          ticks: { autoSkip: false, maxRotation: 45, minRotation: 20 }
        }
      }
    }
  });
}

// ========== SECTOR BAR CHART ========== //
const tsContainer = document.getElementById('sector-chart-container');

const tsCanvas = document.createElement('canvas');
tsCanvas.id = 'sectorBarChart';
tsCanvas.classList.add('bar-chart');
tsCanvas.style.marginBottom = '20px';

const tsWrapper = document.createElement('div');
tsWrapper.classList.add('chart-wrapper');
tsWrapper.style.cssText = 'display:flex;gap:24px;align-items:flex-start';
tsWrapper.appendChild(tsCanvas);
tsContainer.appendChild(tsWrapper);

const sectorLabels = sectorBarData.map(i => i.label),
      sectorValues = sectorBarData.map(i => i.value),
      sectorColors = sectorBarData.map(i => i.color);

new Chart(tsCanvas.getContext('2d'), {
  type: 'bar',
  data: {
    labels: sectorLabels,
    datasets: [{
      label: 'Waste by Sector',
      data: sectorValues,
      backgroundColor: sectorColors
    }]
  },
  options: {
    responsive: true,
    indexAxis: 'y',
    plugins: {
      tooltip: {
        callbacks: {
          label: ({ parsed }) => `${parsed.x.toFixed(3)} kg`
        }
      },
      title: { display: false }
    },
    scales: {
      y: { beginAtZero: true, title: { display: true, text: 'Weight (kg)' } },
      x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 20 } }
    }
  }
});

const tsLegendDiv = document.createElement('div');
tsLegendDiv.classList.add('bar-legend');
tsLegendDiv.innerHTML = createLegendHTML(sectorBarData, sectorValues);
const tsLegendWrapper = document.createElement('div');
tsLegendWrapper.appendChild(tsLegendDiv);
tsWrapper.appendChild(tsLegendWrapper);

// ========== SECTOR PIE CHARTS ========== //
const sectorContainer = document.getElementById('sector-pies-container');

for (const [sectorName, pieData] of Object.entries(sectorPieData)) {
  const tabDiv = document.createElement('div');
  tabDiv.id = sectorName.replace(/\s+/g, '');
  tabDiv.classList.add('sector-tabcontent');
  tabDiv.setAttribute('data-section', `top-${sectorName.toLowerCase()}`);

  const headerDiv = document.createElement('div');
  headerDiv.classList.add('sector-header');
  headerDiv.innerHTML = `
    <h2 class="bar-legend-title">${sectorName} Sector</h2>
    <div class="sector-pie-desc" 
         style="background-color: #eef8f2; padding: 1rem; border-radius: 12px; 
                border-left: 6px solid #4CAF50; margin-bottom: 1rem;
                box-sizing: border-box;">
    </div>
  `;

  const flexWrapper = document.createElement('div');
  flexWrapper.classList.add('sector-flex-wrapper');
  flexWrapper.style.cssText = `
    display: flex;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 24px;
    margin: 0 auto;
    width: fit-content;
  `;

  const canvas = document.createElement('canvas');
  canvas.id = `pieChart-${sectorName.replace(/\s+/g, '-')}`;
  canvas.style.cssText = `
    max-width: 425px; 
    max-height: 400px; 
    margin-bottom: 20px;
  `;

  const legendDiv = document.createElement('div');
  legendDiv.classList.add('bar-legend');
  legendDiv.style.cssText = `
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    flex: 1 1 300px;
  `;
  legendDiv.innerHTML = createLegendHTML(
    pieData.labels.map((label, i) => ({
      label,
      value: pieData.data[i],
      color: pieData.backgroundColor[i]
    })), 
    pieData.data
  );

  flexWrapper.append(canvas, legendDiv);
  tabDiv.append(headerDiv, flexWrapper);
  sectorContainer.appendChild(tabDiv);

  new Chart(canvas.getContext('2d'), {
    type: 'pie',
    data: {
      labels: pieData.labels,
      datasets: [{
        data: pieData.data,
        backgroundColor: pieData.backgroundColor,
        hoverOffset: 20
      }]
    },
    options: {
      animation: { duration: 0 },
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            label: ({ raw }) => {
              const total = pieData.data.reduce((a, b) => a + b, 0);
              const pct = total ? ((raw / total) * 100).toFixed(3).replace(/\.0+$/, '') : '0';
              return `${raw.toFixed(3)} kg (${pct}%)`;
            }
          }
        },
        legend: false,
        title: { display: false }
      }
    }
  });
}

insertOverallInsight();
insertPerSupertypeInsights();
insertSectorInsights();
insertSectorOverviewInsight();

</script>

<!-- Trend zoom script -->
<script>

document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.zoom-range').forEach(slider => {
    const targetId = slider.getAttribute('data-target');
    const container = document.getElementById(targetId);

    if (!container) {
      console.error(`[Zoom] no element found for data-target="${targetId}"`);
      return;
    }

    // This is the width you see on screen when page loads.
    const initialWidth = container.getBoundingClientRect().width;

    // Store the initial width as our 100% reference.
    let baseWidth = initialWidth;

    function applyZoom(rawValue) {
      const percent = Number(rawValue);
      if (isNaN(percent)) return;

      // Convert 25‚Äì200% slider into pixel width
      const newWidth = Math.max(200, baseWidth * (percent / 100));

      container.style.width = `${newWidth}px`;
      container.style.minWidth = `${newWidth}px`;
    }

    // Initialize the zoom according to current slider value
    applyZoom(slider.value);

    // Update continuously as user drags
    slider.addEventListener('input', e => applyZoom(e.target.value));

    // If the viewport changes size, recalibrate the base width
    window.addEventListener('resize', () => {
      baseWidth = container.getBoundingClientRect().width;
      applyZoom(slider.value);
    });
  });
});

</script>

<!-- Map view script -->
<script>
  const locations = {{{locations}}};

  if (locations.length === 0) {
    console.warn("No coordinates available for the selected filters.");
  } else {
    const map = L.map('map').setView([locations[0].latitude, locations[0].longitude], 0);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const bounds = [];

    locations.forEach(loc => {
      if (loc.latitude && loc.longitude) {
        const marker = L.marker([loc.latitude, loc.longitude]).addTo(map);
        bounds.push([loc.latitude, loc.longitude]);
      }
    });

    if (bounds.length > 0) {
      map.fitBounds(bounds, {
        padding: [50, 50]
      });
    }
  }
</script>

<!-- JS behind the tabs -->
<script src="/js/tabs.js"></script>
<script src="/js/tabs-bar.js"></script>
<script src="/js/tabs-sector-pie.js"></script>

<style>

.sim-row {
  display: flex;
  align-items: center;
  gap: 10px;
}
.sim-row label {
  width: 180px;          /* equal label width */
  font-weight: 500;
}
.sim-row input {
  width: 160px !important;          /* equal input width */
}
#runSimBtn {
  width: fit-content;
}

.chart-viewport {
  overflow-x: auto; overflow-y: hidden; width: 100%;
}

.chart-content {
  width: 100%;     /* default baseline */
  min-width: 300px;
}

.zoom-range {
  accent-color: #2d613f; 
}

.chart-zoom-slider {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.recommendation-box {
  background: #fff;
  border-radius: 8px;
  padding: 0.75rem 1rem;
  margin-top: 0.5rem;
  display: flex;
  align-items: center;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}

.bar-canvas {
  max-width: 700px;
}

[data-section="top-categories"] {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 20px;
  flex-wrap: wrap;
  width: 100%;
  box-sizing: border-box;
}

#summary-legend {
  flex: 1 1 400px;
  min-width: 300px;
  max-width: 600px;
  box-sizing: border-box;
  overflow-wrap: break-word;
}

#summary-legend h2 {
  color: #2d613f;
  margin-bottom: 0.5rem;
}

#summary-legend p {
  font-size: 1rem;
  line-height: 1.4;
}

.click-note {
  color: gray;
  font-style: italic;
  font-size: medium;
}

.participants-list {
  display: none;
}

.participants-list .content {
  max-height: 300px;
  overflow-y: scroll;
  overflow-x: hidden;
  display: flex;
}

.participants-header {
  color: #2d613f;
  font-weight: 600;
  margin-bottom: 1rem;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.toggle-icon {
  transition: transform 0.3s ease;
}

.open .toggle-icon {
  transform: rotate(180deg);
}

.high-priority {
  color: #127009;
  background-color: #c2f3ce;
  padding: 0.75rem;
  border-left: 4px solid #127009;
  border-radius: 6px;
  display: block;
}

.mid-priority {
  color: #cc7a00;
  background-color: #fff4e0;
  padding: 0.75rem;
  border-left: 4px solid #cc7a00;
  border-radius: 6px;
  display: block;
}

.low-priority {
  color: #b30000;
  background-color: #ffe6e6;
  padding: 0.75rem;
  border-left: 4px solid #b30000;
  border-radius: 6px;
  display: block;
}

.insight-general {
  background-color: #eef8f2;
  padding: 1.5rem;
  border-radius: 12px;
  border-left: 6px solid #4CAF50;
  margin-top: 2rem;
}

.insight-compliance {
  background: white;
  border: 1px solid #b5e0b5;
  border-radius: 10px;
  padding: 16px 20px;
  margin: 14px 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  color: #1e4620;
  font-size: 0.95rem;
}
.insight-compliance h3 {
  color: #2e7d32;
  font-size: 1rem;
  margin-bottom: 8px;
}

.compliance-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
  font-size: 0.95rem;
  background-color: #ffffff;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
}

.compliance-table th {
  background-color: #c8e6c9;
  color: #1b5e20;
  text-align: left;
  padding: 10px 12px;
  font-weight: 600;
  border-bottom: 2px solid #a5d6a7;
}

.compliance-table td {
  padding: 9px 12px;
  border-bottom: 1px solid #e0f2e0;
  color: #2e4630;
}

.compliance-table tr:nth-child(even) {
  background-color: #f9fff9;
}

.compliance-table tr:hover {
  background-color: #eef9ee;
  transition: background-color 0.15s ease-in-out;
}

.compliance-table td:nth-child(2),
.compliance-table td:nth-child(3),
.compliance-table td:nth-child(4),
.compliance-table td:nth-child(5) {
  text-align: right;
}

.compliance-table td:nth-child(6) {
  text-align: center;
  font-weight: 600;
}

.non-compliant {
  color: #c62828 !important;
}

.filter-columns {
  display: flex;
  gap: 2rem;
  flex-wrap: wrap;
}

.filter-column {
  flex: 1 1 300px;
  display: flex;
  flex-direction: column;
}

.filter-column label {
  font-weight: 600;
  margin-top: 0.8rem;
  margin-bottom: 0.3rem;
}

.filter-section {
  background: #fafafa;
  border: 1px solid #ccc;
  padding: 1.5rem;
  border-radius: 10px;
  margin-bottom: 1rem;
}

.trend-chart-box {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  margin-bottom: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.trend-chart-box canvas {
  width: 100% !important;
  height: 100% !important;
  max-width: none !important;
}

/* Prevent Chart.js from keeping a minimum width */
.chart-canvas-wrapper,
.trend-chart-box [id$="Container"] {
  min-width: 0 !important;
}

[style*="overflow-x: auto"] {
  min-width: 0 !important;
}

.trend-chart-box h3 {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#trend-charts-wrapper {
  gap: 1.5rem;
}

.trend-chart-box canvas {
  background: linear-gradient(to bottom, #ffffff 0%, #f8fdf8 100%);
  border-radius: 8px;
  padding: 10px;
}

.trend-chart-box {
  position: relative;
  overflow: visible;
}

#trendTotalWasteContainer,
#trendPerCapitaContainer,
#trendByCategoryContainer,
#trendComplianceContainer {
  overflow-x: auto;
  overflow-y: hidden;
  position: relative;
  height: 320px;
  padding-bottom: 10px;
}

#trendTotalWasteContainer::-webkit-scrollbar,
#trendPerCapitaContainer::-webkit-scrollbar,
#trendByCategoryContainer::-webkit-scrollbar,
#trendComplianceContainer::-webkit-scrollbar {
  height: 8px;
}

#trendTotalWasteContainer::-webkit-scrollbar-track,
#trendPerCapitaContainer::-webkit-scrollbar-track,
#trendByCategoryContainer::-webkit-scrollbar-track,
#trendComplianceContainer::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#trendTotalWasteContainer::-webkit-scrollbar-thumb,
#trendPerCapitaContainer::-webkit-scrollbar-thumb,
#trendByCategoryContainer::-webkit-scrollbar-thumb,
#trendComplianceContainer::-webkit-scrollbar-thumb {
  background: #4CAF50;
  border-radius: 4px;
}

#trendTotalWasteContainer::-webkit-scrollbar-thumb:hover,
#trendPerCapitaContainer::-webkit-scrollbar-thumb:hover,
#trendByCategoryContainer::-webkit-scrollbar-thumb:hover,
#trendComplianceContainer::-webkit-scrollbar-thumb:hover {
  background: #388E3C;
}

.info-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  justify-content: center;
}

.info-grid .form-section {
  flex: 1 1 280px;
  min-width: 280px;
}

.user-profile {
  width: 100%;
  border-collapse: collapse;
  margin-top: 0.5rem;
}

.user-profile td {
  padding: 0.5rem 0.75rem;
  border-bottom: 1px solid #eee;
}

.user-profile .label {
  font-weight: 600;
  color: #444;
  width: 50%;
}

.title-card h1 {
  font-size: 1.75rem;
}

.btn-submit {
  background-color: #28a745;
  border: none;
  padding: 0.6rem 1.2rem;
  color: white;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s ease;
}

.btn-submit:hover {
  background-color: #218838;
}

.tab-new {
  text-align: center;
  margin-top: 2rem;
}

.tab-new button {
  background-color: #f1f1f1;
  border: none;
  padding: 0.75rem 1.5rem;
  margin: 0 5px;
  cursor: pointer;
  font-weight: 600;
  border-radius: 8px;
  transition: background-color 0.2s;
}

.tab-new button:hover,
.tab-new button.active {
  background-color: #d0e6ff;
}

.form-section {
  background-color: #fdfdfd;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid #ccc;
  margin: 1.5rem auto;
  font-family: 'Segoe UI', sans-serif;
  color: #333;
}

.form-section h3 {
  font-size: 1.25rem;
  margin-bottom: 1rem;
  color: #2c3e50;
  align-items: center;
}

.form-section h3 i {
  margin-right: 0.6rem;
  color: #127009;
}

.form-section label {
  display: block;
  margin-top: 1rem;
  font-weight: 600;
  font-size: 0.95rem;
}

.form-section input[type="text"],
.form-section input[type="date"],
.form-section input[type="number"],
.form-section select {
  width: 100%;
  padding: 0.5rem;
  margin-top: 0.3rem;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 1rem;
}

.pie-legend {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 12px;
}

.pie-chart {
  flex: 1 1 350px;
  max-width: 500px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.legend-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-radius: 6px;
  color: white;
  font-weight: 500;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  box-sizing: border-box;
}

.legend-name {
  display: flex;
  flex-direction: column;
}

.legend-perc {
  font-size: 0.85rem;
  opacity: 0.9;
}

.legend-kg {
  font-weight: 700;
  font-size: 1.05rem;
}

#togglePieBtn {
  margin-top: 20px;
  padding: 10px 20px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.3s;
}

#togglePieBtn:hover {
  background-color: #45a049;
}

.chart-wrapper {
  display: flex;
  gap: 24px;
  align-items: flex-start;
  margin-bottom: 40px;
}

.bar-legend {
  flex: 1;
  min-width: 250px;
}

.bar-legend-title {
  color: #2d613f;
  margin-bottom: 1rem;
  font-size: 1.2rem;
  text-align: center;
}

.bar-legend-name {
  display: flex;
  flex-direction: column;
}

.bar-legend-perc {
  font-size: 0.85rem;
  opacity: 0.9;
}

.bar-legend-kg {
  font-weight: 700;
  font-size: 1.05rem;
}

.tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #f1f1f1;
  text-align: center;
  border-radius: 8px 8px 0 0;
  margin-top: 20px;
}

.tab button {
  background-color: inherit;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 14px 16px;
  transition: 0.3s;
  font-size: 17px;
  font-weight: 600;
  color: #333;
}

.tab button:hover {
  background-color: #ddd;
}

.tab button.active {
  background-color: #4CAF50;
  color: white;
}

.tabcontent {
  display: none;
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 8px 8px;
  background-color: white;
}

.bar-tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #e8f5e9;
  text-align: center;
  border-radius: 8px 8px 0 0;
  margin-top: 20px;
}

.bar-tab button {
  background-color: inherit;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 12px 14px;
  transition: 0.3s;
  font-size: 15px;
  font-weight: 600;
  color: #2d613f;
}

.bar-tab button:hover {
  background-color: #c8e6c9;
}

.bar-tab button.active {
  background-color: #4CAF50;
  color: white;
}

.bar-tabcontent {
  display: none;
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 8px 8px;
  background-color: white;
}

.sector-tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #e3f2fd;
  text-align: center;
  border-radius: 8px 8px 0 0;
  margin-top: 20px;
}

.sector-tab button {
  background-color: inherit;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 12px 14px;
  transition: 0.3s;
  font-size: 15px;
  font-weight: 600;
  color: #1565C0;
}

.sector-tab button:hover {
  background-color: #bbdefb;
}

.sector-tab button.active {
  background-color: #2196F3;
  color: white;
}

.sector-tabcontent {
  display: none;
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 8px 8px;
  background-color: white;
}

#map {
  height: 400px;
  border-radius: 8px;
  border: 2px solid #ccc;
}

@media print {
  .modal {
    display: none !important;
  }
  
  .btn-customize {
    display: none !important;
  }
  
  body {
    background: white;
  }
  
  .form-section {
    page-break-inside: avoid;
  }
}

.simulation-container {
  background-color: #fdfdfd;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid #ccc;
  margin: 2rem auto;
  max-width: 950px;
  color: #333;
  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
}

.model-controls {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

button {
  background-color: #28a745;
  border: none;
  color: #fff;
  padding: 0.6rem 1.2rem;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
}

button:hover {
  background-color: #23963b;
}

.summary-box {
  margin-top: 1rem;
  padding: 1rem;
  border: 1px solid #ccc;
  border-radius: 10px;
  background-color: #f9fff9;
  font-family: 'Segoe UI', sans-serif;
}

#simulationChart {
  background: #f8fdf8;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  padding: 10px;
}

</style>